#!/usr/bin/env python

import os, sys

OLD_SAGE_ROOT = None
SAGE_ROOT     = os.path.realpath(os.environ['SAGE_ROOT'])

location_file = os.path.join(SAGE_ROOT, 'local', 'lib', 'sage-current-location.txt')
flags_file    = os.path.join(SAGE_ROOT, 'local', 'lib', 'sage-flags.txt')

# The flags we care about recording in the local/lib/sage-flags.txt file
# In SAGE_FAT_BINARY mode we only require that ['sse', 'sse2', '3d',
#  'mmx', 'cmov'] be available, and in particular, don't require pni
#  or ssse3.

try:
    SAGE_FAT_BINARY = os.environ['SAGE_FAT_BINARY']
except:
    SAGE_FAT_BINARY = ""

if SAGE_FAT_BINARY == "yes":
    FLAGS = ['sse', 'sse2', '3d', 'mmx', 'cmov']
else:
    FLAGS = ['sse', 'sse2', 'ssse3', '3d', 'mmx', 'pni', 'cmov']


def write_location_file():
    """
    Write the location file with the current SAGE_ROOT
    """
    # Write new location file.
    O = open(location_file,'w')
    O.write(SAGE_ROOT)
    O.close()

def read_location_file():
    """
    If the location file exists, return the real path contained in it.  Otherwise, return None.
    """
    if os.path.exists(location_file):
        # The install moved and we had written the flags and location files.
        O = open(location_file)
        R = O.read().strip()
        O.close()
        return os.path.realpath(R)
    else:
        return None

def install_moved():
    """
    Check whether or not this install of Sage moved.  If it hasn't
    moved make sure the location and processor flags files are
    written.

    Returns True if location possibly moved, and sets the global
    OLD_SAGE_ROOT variable to the old SAGE_ROOT path.

    Returns False if location has not moved.
    """
    # Write the flags file if it isn't there.
    if not os.path.exists(flags_file):
        f=open(flags_file,'w')
        f.write(get_flags_info())
        f.close()

    path=read_location_file()
    if path is None:
        # first time checked (during the build)
        write_location_file()
        initialize_pkgconfig_files()
        return False
    elif path != SAGE_ROOT:
        # location moved
        global OLD_SAGE_ROOT
        OLD_SAGE_ROOT=path
        write_location_file()
        return True
    else:
        # path didn't change
        return False

def get_flags_info():
    """
    Return a space-separated string that lists the flags supported by
    this CPU from /proc/cpuinfo.
    """
    try:
        r = open('/proc/cpuinfo').read()
        i = r.find('flags')
        r = r[i:]
        i = r.find(':')
        r = r[i+1:]
        i = r.find('\n')
        r = r[:i]

        # This line restricts the flags to just ones that start with sse, 3d or mmx.
        # We do not want *all* flags, since some like "up" are not relevant (up = uniprocessor).
        return ' '.join(set(x for x in r.split() if x in FLAGS))

    except IOError:
        # On a system without /proc/cpuinfo, so don't bother. In
        # particular, for non Linux systems I have no clue how to get
        # the processor flags, and we so far have never ever had any
        # problem with processor flags on such machines.  So we don't
        # bother.
        return ''

def check_processor_flags():
    """
    Make sure all processor flags from the build machine are on this machine.
    If the sage-flags.txt file is missing, don't bother to do this check.
    """
    if not os.path.exists(flags_file): return
    # We check that the processor flags of the original build are a
    # subset of the new machine.  If not, we print a massive warning.
    X = set(open(flags_file).read().split()).intersection(FLAGS)
    Y = set(get_flags_info().split())
    if not X.issubset(Y):
        print ""
        print "*"*70
        print "WARNING!  This Sage install was built on a machine that supports"
        print "instructions that are not available on this computer.  Sage will"
        print "likely fail with ILLEGAL INSTRUCTION errors! The following processor"
        print "flags were on the build machine but are not on this computer:\n"
        for a in X:
            if a not in Y:
                print a,
        print ""
        print ""
        print "Email http://groups.google.com/group/sage-support for help."
        print "To remove this warning and make Sage start, just delete"
        print "     %s"%flags_file
        print "*"*70
        sys.exit(1)

def update_library_files():
    """
    Run ranlib on the library directory and manually change the path
    in .la library files.
    """
    LIB = os.path.join(os.path.abspath(SAGE_ROOT), 'local', 'lib')
    # The .a files should be re-ranlib'd
    os.system('cd "%s"; ranlib *.a 1>/dev/null 2>/dev/null'%LIB)

    # The .la files hardcode path info, so we manually fix the path
    # info
    for F in os.listdir(LIB):
       if os.path.splitext(F)[1]==".la":
           G = open(os.path.join(LIB,F)).read()
	   i = G.find('libdir=')
	   j = i+8 + G[i+8:].find("'")
	   z = G[i+8:j].strip().strip("'")
 	   i = z.rfind('local/')
	   if i != -1:
               z = z[:i]
               H = G.replace(z, os.path.abspath(SAGE_ROOT) + '/')
               open(os.path.join(LIB, F),'w').write(H)


def initialize_pkgconfig_files():
    """
    Insert a sage_local variable in each pkg_config file and replace
    them to make the paths portable.
    """
    LIB = os.path.join(os.path.abspath(SAGE_ROOT), 'local', 'lib')
    PKG = os.path.join(LIB,'pkgconfig')
    for name in os.listdir(PKG):
        filename=os.path.join(PKG,name)
        if os.path.splitext(filename)[1]==".pc":
            with open(filename) as file:
                config = file.read()

            new_config = config.replace(os.path.abspath(SAGE_ROOT), "${SAGE_ROOT}")

            new_config = 'SAGE_ROOT=%s\n'%os.path.abspath(SAGE_ROOT)+new_config

            with open(filename, 'w') as file:
                file.write(new_config)



def update_pkgconfig_files():
    """
    Change paths in package configuration files.
    """
    LIB = os.path.join(os.path.abspath(SAGE_ROOT), 'local', 'lib')
    PKG = os.path.join(LIB,'pkgconfig')
    for name in os.listdir(PKG):
        filename=os.path.join(PKG,name)
        if os.path.splitext(filename)[1]==".pc":
            with open(filename) as file:
                config = file.read()

            prefix_start=config.find('SAGE_ROOT=')
            prefix_end=config.find('\n', prefix_start)
            new_prefix='SAGE_ROOT=%s'%os.path.abspath(SAGE_ROOT)
            new_config=config[:prefix_start]+new_prefix+config[prefix_end:]

            with open(filename, 'w') as file:
                file.write(new_config)


def remove_files(path, remove_extensions):
    """
    Walk the tree starting at path and remove all files with
    extensions in remove_ext.  The extensions in remove_extensions
    should start with a period, i.e., remove_files(path, ('.pyc',
    '.pyo')).
    """
    for root, dirs, files in os.walk(path):
        for file in files:
            filename=os.path.join(root,file)
            if os.path.splitext(filename)[1] in remove_extensions:
                try:
                    os.unlink(filename)
                except OSError, msg:
                    print msg

def __mysig(a,b):
    raise KeyboardInterrupt, "computation timed out because alarm was set for %s seconds"%__alarm_time

if __name__ ==  '__main__':

    check_processor_flags()
    if install_moved():
        print "The Sage install tree may have moved"
        print "(from %s to %s)"%(OLD_SAGE_ROOT, SAGE_ROOT)
        print "Changing various hardcoded paths"
        print "(please wait at most a few minutes)..."
        print "Do not interrupt this."
	update_library_files()
        update_pkgconfig_files()
        # Compiled python files need to be regenerated, so we remove them
        remove_files(os.path.join(SAGE_ROOT, 'local', 'lib', 'python'),
                     remove_extensions=('.pyc', '.pyo'))
        print "Done resetting paths"
