#!/usr/bin/env python

import os, sys

OLD_SAGE_ROOT = None
SAGE_ROOT     = os.path.realpath(os.environ['SAGE_ROOT'])

location_file = os.path.join(SAGE_ROOT, 'local', 'lib', 'sage-current-location.txt')
flags_file    = os.path.join(SAGE_ROOT, 'local', 'lib', 'sage-flags.txt')


# The flags we care about recording in the local/lib/sage-flags.txt file.
# In SAGE_FAT_BINARY mode we only require that ['sse', 'sse2', '3d',
# 'mmx', 'cmov'] be available, and in particular, we don't require pni
# (Prescott New Instructions, including SSE3) or ssse3.

SAGE_FAT_BINARY = os.environ.get('SAGE_FAT_BINARY',"")

if SAGE_FAT_BINARY == "yes":
    FLAGS = ['sse', 'sse2', '3d', 'mmx', 'cmov']
else:
    FLAGS = ['sse', 'sse2', 'ssse3', '3d', 'mmx', 'pni', 'cmov']


def write_location_file():
    """
    Write the location file with the current value of ``SAGE_ROOT``.
    """
    # Write new location file.
    O = open(location_file,'w')
    O.write(SAGE_ROOT)
    O.close()

def read_location_file():
    """
    If the location file exists, return the real path contained in it.
    Otherwise return ``None``.
    """
    if os.path.exists(location_file):
        # The install moved and we had written the flags and location files.
        O = open(location_file)
        R = O.read().strip()
        O.close()
        return os.path.realpath(R)
    else:
        return None


def install_moved():
    """
    Check whether or not this installation of Sage has moved.  If it hasn't
    moved, make sure the location and processor flags files are written.

    Return ``True`` if location possibly changed, and set the global
    ``OLD_SAGE_ROOT`` variable to the old ``SAGE_ROOT`` path.

    Return ``False`` if the Sage installation hasn't moved.
    """
    # Write the flags file if it isn't there:
    if not os.path.exists(flags_file):
        f=open(flags_file,'w')
        f.write(get_flags_info())
        f.close()

    path=read_location_file()
    if path is None:
        # first time checked (during the build)
        write_location_file()
        update_library_files()
        initialize_pkgconfig_files()
        return False
    elif path != SAGE_ROOT:
        # location moved
        global OLD_SAGE_ROOT
        OLD_SAGE_ROOT = path
        write_location_file()
        return True
    else:
        # path didn't change
        return False


def get_flags_info():
    """
    Return a space-separated string that lists the flags indicating what's
    supported by this CPU by reading ``/proc/cpuinfo``.
    """
    try:
        r = open('/proc/cpuinfo').read()
        i = r.find('flags')
        r = r[i:]
        i = r.find(':')
        r = r[i+1:]
        i = r.find('\n')
        r = r[:i]

        # This line restricts the flags to just ones that start with sse, 3d or mmx.
        # We do not want *all* flags, since some like "up" are not relevant (up = uniprocessor).
        return ' '.join(set(x for x in r.split() if x in FLAGS))

    except IOError:
        # On a system without /proc/cpuinfo, so don't bother.  In
        # particular, for non-Linux systems I have no clue how to get
        # the processor flags, and we so far have never ever had any
        # problem with processor flags on such machines.  So we don't
        # bother.
        return ''


def check_processor_flags():
    """
    Make sure all processor flags from the build machine are on this machine.
    If the ``sage-flags.txt`` file is missing, don't bother to do this check.
    """
    if not os.path.exists(flags_file): return
    # We check that the processor flags of the original build are a
    # subset of the new machine.  If not, we print a massive warning.
    X = set(open(flags_file).read().split()).intersection(FLAGS)
    Y = set(get_flags_info().split())
    if not X.issubset(Y):
        print ""
        print "*"*70
        print "WARNING!  This Sage install was built on a machine that supports"
        print "instructions that are not available on this computer.  Sage will"
        print "likely fail with ILLEGAL INSTRUCTION errors! The following processor"
        print "flags were on the build machine but are not on this computer:\n"
        for a in X:
            if a not in Y:
                print a,
        print ""
        print ""
        print "Email http://groups.google.com/group/sage-support for help."
        print "To remove this warning and make Sage start, just delete"
        print "     %s"%flags_file
        print "*"*70
        sys.exit(1)


def update_library_files():
    """
    Run ``ranlib`` on all static libraries (``*.a``) in the library directory,
    and manually change the paths in all of ``libtool``'s ``.la`` library files.
    """
    LIB = os.path.join(os.path.abspath(SAGE_ROOT), 'local', 'lib')
    # The .a files should be re-ranlib'd:
    os.system('cd "%s"; ranlib *.a 1>/dev/null 2>/dev/null' % LIB)

    # The .la files hardcode path info, so we manually fix the path info:
    for F in os.listdir(LIB):
       if os.path.splitext(F)[1]==".la":
           G = open(os.path.join(LIB,F)).read()
           i = G.find('libdir=')
           j = i+8 + G[i+8:].find("'")
           z = G[i+8:j].strip().strip("'")
           i = z.rfind('local/')
           if i != -1:
               z = z[:i]
               H = G.replace(z, os.path.abspath(SAGE_ROOT) + '/')
               open(os.path.join(LIB, F),'w').write(H)


def initialize_pkgconfig_files():
    """
    Insert a ``SAGE_ROOT`` variable into each ``pkg-config`` file and replace
    occurrences of its current value by references to it (``${SAGE_ROOT}``).
    This way we only have to change the definition of ``SAGE_ROOT`` whenever
    the Sage installation has moved, i.e., paths have changed.
    """
    SAGE_ROOT_absolute = os.path.abspath(SAGE_ROOT)
    LIB = os.path.join(SAGE_ROOT_absolute, 'local', 'lib')
    PKG = os.path.join(LIB, 'pkgconfig')
    import re
    # Pattern matching a *definition* of SAGE_ROOT:
    def_pat = re.compile(r"^SAGE_ROOT=.*\n", re.MULTILINE)
    # Pattern matching the current *value* of SAGE_ROOT (absolute path):
    # (For the alternate implementation below only.  Will have weird effects
    # in case SAGE_ROOT_absolute contains other characters having special
    # meaning in regular expressions.  IMHO rather unlikely, but one never
    # knows...)
    # use_pat = re.compile(SAGE_ROOT_absolute.replace(".", r"\."))

    for name in os.listdir(PKG):
        filename = os.path.join(PKG, name)
        if os.path.splitext(filename)[1]==".pc":
            with open(filename) as file:
                config = file.read()

            if def_pat.search(config):
                # There are already one or more definitions of SAGE_ROOT,
                # which also happens if we previously processed the same
                # file (here) because of [symbolic or hard] links, so this
                # isn't necessarily an error. (Cf. #11760).
                # For simplicity, we just remove any definition, and only
                # issue a warning if there was more than one, and don't
                # check whether a previous definition was already current:
                config, n = def_pat.subn("", config)
                if n>1:
                    sys.stderr.write(
                        "Warning: sage_location: initialize_pkgconfig_files():\n" +
                        "  File \"%s\" already contained %d definitions of SAGE_ROOT.\n" %
                            (name, n) +
                        "  These will get replaced by a single, current definition.\n")
                    sys.stderr.flush()

            # Replace all occurrences of the (current) value of SAGE_ROOT
            # by references to the pkg-config variable SAGE_ROOT:
            config = config.replace(SAGE_ROOT_absolute, "${SAGE_ROOT}")
            # Alternate implementation, *may* be faster:
            # config = use_pat.sub("${SAGE_ROOT}", config)

            definition = "SAGE_ROOT=%s\n" % SAGE_ROOT_absolute
            with open(filename, 'w') as file:
                file.write(definition + config)


def update_pkgconfig_files():
    """
    Change / update paths in all ``pkg-config`` (``*.pc``) files pointing into
    the Sage installation tree, which is necessary whenever Sage has moved.
    Requires that the files have previously been processed by
    ``initialize_pkgconfig_files()``, in particular, each of them contains a
    definition of the variable ``SAGE_ROOT``, since only that is updated here.
    """
    SAGE_ROOT_absolute = os.path.abspath(SAGE_ROOT)
    LIB = os.path.join(SAGE_ROOT_absolute, 'local', 'lib')
    PKG = os.path.join(LIB, 'pkgconfig')
    import re
    # Pattern matching a *definition* of SAGE_ROOT:
    def_pat = re.compile(r"^SAGE_ROOT=.*\n", re.MULTILINE)

    for name in os.listdir(PKG):
        filename = os.path.join(PKG, name)
        if os.path.splitext(filename)[1]==".pc":
            with open(filename) as file:
                config = file.read()

            if not def_pat.search(config):
                # There's no definition of SAGE_ROOT in the .pc file at all.
                # This should never happen, unless the user modified the file.
                sys.stderr.write(
                    "Error: sage_location: update_pkgconfig_files():\n" +
                    "  File \"%s\" doesn't contain a definition of SAGE_ROOT.\n" %
                    name + "  Skipping it...\n")
                sys.stderr.flush()
                continue
                # We could of course call initialize_pkgconfig_file(filename)
                # here instead to fix this issue, but unfortunately there's no
                # such function (for a single file) [yet].

            # Delete all previous definitions of SAGE_ROOT:
            config = def_pat.sub("", config)

            definition = "SAGE_ROOT=%s\n" % SAGE_ROOT_absolute
            with open(filename, 'w') as file:
                file.write(definition + config)


def remove_files(path, remove_extensions):
    """
    Walk the tree starting at ``path``, and remove all files with
    extensions in ``remove_extensions``.
    The extensions in ``remove_extensions`` should start with a period, i.e.,
    e.g. use ``remove_files(path, ('.pyc', '.pyo'))``.
    """
    for root, dirs, files in os.walk(path):
        for file in files:
            filename = os.path.join(root, file)
            if os.path.splitext(filename)[1] in remove_extensions:
                try:
                    os.unlink(filename)
                except OSError, msg:
                    print msg


def __mysig(a,b):
    raise KeyboardInterrupt, "Computation timed out because alarm was set for %s seconds." % __alarm_time


if __name__ == '__main__':

    check_processor_flags()
    # Note: install_moved() may also run e.g. initialize_pkgconfig_files().
    if install_moved():
        print "The Sage installation tree may have moved"
        print "(from %s to %s)." % (OLD_SAGE_ROOT, SAGE_ROOT)
        print "Changing various hardcoded paths..."
        print "(Please wait at most a few minutes.)"
        print "DO NOT INTERRUPT THIS."
        sys.stdout.flush() # One never knows...
        update_library_files()
        update_pkgconfig_files()
        # Compiled python files need to be regenerated, so we remove them:
        remove_files(os.path.join(SAGE_ROOT, 'local', 'lib', 'python'),
                     remove_extensions=('.pyc', '.pyo'))
        print "Done resetting paths."
