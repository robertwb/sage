#!/usr/bin/env bash

# William Stein, 2005-12-20 -- removed "m" option from tar,
# which was seriously confusing the build process on some
# (too fast?) machines, especially for mpfr.

#######################################################
#  Install a Sage package.  This script is
#  typically invoked by giving the command
#      sage -i <package name>
#
#  A package may assume that the following environment
#  variables are defined:
#
#      SAGE_ROOT   -- root directory of sage install
#      SAGE_LOCAL  -- $SAGE_ROOT/local
#      SAGE_DATA   -- $SAGE_ROOT/data
#      LIBRARY_PATH, PYTHONPATH, LD_LIBRARY_PATH, DYLD_LIBRARY_PATH
#      CC, CXX, CFLAGS, CXXFLAGS, LDFLAGS, MAKE
#
#  Your package script should try to build using the giving CC, CXX,
#  CFLAGS, MAKE, etc, via a file spkg-install in your script.
#
#  This script does the following:
#
#      1. Set environment variables (by calling sage-env)
#      2. Decompress package into a build directory
#      3. Run the script in the package called spkg-install
#      4. Return error 1 if anything goes wrong.
#
#######################################################

mymkdir()
{
    if [ ! -d $1 ]; then
        mkdir $1
    fi
}

no_version()
{
    if [ -z "`echo "$1" | grep -`" ]; then
        echo "no version"
    fi
}

# error_msg(header, command)
# This is for printing an error message if something went wrong.
# The first argument is the header to print, the second argument should
# be some proposed command to run in the subshell, e.g. "make".
error_msg()
{
cat >&2 <<MESSAGE
************************************************************************
$1
************************************************************************
Please email sage-devel (http://groups.google.com/group/sage-devel)
explaining the problem and including the relevant part of the log file
  $SAGE_ROOT/spkg/logs/$PKG_NAME.log
Describe your computer, operating system, etc.
If you want to try to fix the problem yourself, *don't* just cd to
`pwd` and type '$2' or whatever is appropriate.
Instead, the following commands setup all environment variables
correctly and load a subshell for you to debug the error:
  (cd '`pwd`' && '$SAGE_ROOT/sage' -sh)
When you are done debugging, you can type "exit" to leave the subshell.
************************************************************************
MESSAGE
}

# Handle -n, -t, -q options for recursive make
# See Trac #12016.
if echo "$MAKE $MAKEFLAGS -$MAKEFLAGS" |grep '[ ]-[A-Za-z]*[qnt]' >/dev/null; then
    if echo "$MAKE $MAKEFLAGS -$MAKEFLAGS" |grep '[ ]-[A-Za-z]*q' >/dev/null; then
        # Pretend the target is *not* up-to-date
        exit 1
    else
        exit 0
    fi
fi

# The following sets environment variables for building packages.
# Since this is sourced, it returns a non-zero value on errors rather
# than exiting.  Using dot suggested by W. Cheung.
. "$SAGE_ROOT/spkg/bin/sage-env"

if [ $? -ne 0 ]; then
    echo "Error setting environment variables by sourcing '$SAGE_ROOT/spkg/bin/sage-env';"
    echo "possibly contact sage-devel (see http://groups.google.com/group/sage-devel)."
    exit 1
fi

if [ $# -eq 0 ]; then
    echo "Currently installed packages:"
    ls -1 "$SAGE_PACKAGES/installed/"
    exit 0
fi


cd "$SAGE_PACKAGES"
mymkdir "$BUILD"
mymkdir installed
cd "$BUILD"
mymkdir old

# the following two options are mutually exclusive -- i.e., you
# can give only one.

INFO=0
if [ $1 = '-info' ]; then
    INFO=1
    shift
fi

FORCE=0
if [ $1 = '-f' ]; then
    FORCE=1
    shift
fi
export FORCE

DELETE_TMP=1
if [ $1 = '-s' -o $1 = '-m' ]; then
    DELETE_TMP=0
    shift
fi

INSTALLED="$SAGE_PACKAGES/installed/"
PKG_NAME=`echo "$1" | sed -e "s/\.spkg$//"`
PKG_NAME=`basename "$PKG_NAME"`
PKG_SRC="$1"
PKG_BASE=`echo "$PKG_NAME" | sed -e "s/-.*//"`

# check if noclobber is set and warn about it
if [ $PKG_SRC == "noclobber" ]; then
    echo "***********************************************************"
    echo "* WARNING WARNING WARNING WARNING WARNING WARNING WARNING *"
    echo "*                                                         *"
    echo "* noclobber is set in .bashrc and/or .bash_profile - you  *"
    echo "* should consider disabling it. The Sage install should   *"
    echo "* continue to work, so don't worry about it too much.     *"
    echo "*                                                         *"
    echo "* WARNING WARNING WARNING WARNING WARNING WARNING WARNING *"
    echo "***********************************************************"
    exit 0
fi

if [ ! -f "$PKG_SRC" ]; then
    if [ -f "$SAGE_PACKAGES/standard/$PKG_NAME.spkg" ]; then
        PKG_SRC="$SAGE_PACKAGES/standard/$PKG_NAME.spkg"
    else
        if [ -f "$SAGE_PACKAGES/optional/$PKG_NAME.spkg" ]; then
            PKG_SRC="$SAGE_PACKAGES/optional/$PKG_NAME.spkg"
        else
            CUR=`pwd`
            cd "$SAGE_PACKAGES"
            PKG_NEWEST_VER=`./standard/newest_version "$PKG_NAME" 2> /dev/null`
            if [ -n "$PKG_NEWEST_VER" ]; then
                PKG_SRC="$SAGE_PACKAGES/standard/$PKG_NEWEST_VER.spkg"
            else
                PKG_NEWEST_VER=`./standard/newest_version -base "$PKG_NAME" 2> /dev/null`
                if [ -n "$PKG_NEWEST_VER" ]; then
                    PKG_SRC="$SAGE_PACKAGES/standard/$PKG_NEWEST_VER.spkg"
                fi
            fi
        fi
    fi
fi

# Don't verbosely extract files from spkgs by default (#10040):

if [ "$SAGE_SPKG_LIST_FILES" = "yes" ]; then
    UNTAR_VERBOSE=v
else
    unset UNTAR_VERBOSE
fi

if [ $INFO -ne 0 ]; then
    if [ ! -f "$PKG_SRC" ]; then
        echo "Package $PKG_NAME not found"
    fi
    bunzip2 -c "$PKG_SRC" 2>/dev/null | tar Ofx${UNTAR_VERBOSE} - $PKG_NAME/SAGE.txt 2>/dev/null
    if [ $? -ne 0 ]; then
        tar Ofx${UNTAR_VERBOSE} "$PKG_SRC" "$PKG_NAME/SAGE.txt" 2>/dev/null
    fi
    echo ""
    if [ $? -ne 0 ]; then
        echo "No file SAGE.txt in $PKG_NAME"
        exit 1
    fi
    exit 0
fi

echo "$PKG_NAME"

echo "Machine:"
uname -a

if [ -f "$INSTALLED/$PKG_NAME" -a $FORCE -eq 0 ]; then
    echo "sage: $1 is already installed"
    touch "$INSTALLED/$PKG_NAME"
    exit 0
fi

cd "$SAGE_PACKAGES/build"

if [ $DELETE_TMP -eq 1 ]; then
    echo "Deleting directories from past builds of previous/current versions of $PKG_NAME"
    # Make triply sure that we are in the build directory before doing
    # a scary "rm -rf".
    cd "$SAGE_PACKAGES/build"
    if [ $? -ne 0 ]; then
        echo "Unable to find build directory."
    else
        rm -rf "$PKG_BASE-"*
    fi
else
    echo "Moving directories from past builds of previous/current versions of $PKG_NAME to build/old"
    mv -f "$PKG_BASE-"* old/  2>/dev/null
fi

if [ ! -f "$PKG_SRC" ]; then

    echo "$0: file $PKG_NAME does not exist"
    echo "Attempting to download it."
    CUR=`pwd`
    cd "$SAGE_PACKAGES"
    if [ ! -d optional ]; then
        mkdir optional
    fi
    cd optional

    FOUND_VERSION=''
    if [ -n "`no_version "$PKG_NAME"`" ]; then
        echo "Searching for latest version of $PKG_NAME"
        PKG_NAME=`sage-latest-online-package "$PKG_NAME"`
        if [ $? -eq 0 ]; then
            echo "Found package $PKG_NAME"
            FOUND_VERSION='1'
        else
            echo "$PKG_NAME"
            exit 1
        fi
    fi

    # See trac ticket #7544. One should be able to install a package using
    # sage -i <package-name> where <package-name> can be any of the
    # following values:
    #
    # 1. <package>-x.y.z, i.e. the name of the package plus the package's
    #    version numbers.
    # 2. the full name <package>-x.y.z.spkg, i.e. the name of the package in
    #    addition to the version numbers and the ".spkg" extension.
    # 3. <URL>/<package>-x.y.z.spkg, i.e. the full URL where the package is
    #    hosted. This can be a URL on the Sage website or somewhere else.
    # 4. /path/to/<package>-x.y.z.spkg, i.e. the package is found somewhere
    #    in your file system and you're giving an absolute or relative path
    #    to the package.
    #
    # See trac ticket #8043. If no version was specified but a version
    # was found above, then $PKG_NAME now contains the version number.
    # Download this, since it's a known Sage package.  Otherwise,
    # download the package specified by $1, since it either already
    # contains the version number or is a URL.
    if [ "x$FOUND_VERSION" = "x" ]; then
        sage-download_package "$1"
    else
        sage-download_package "$PKG_NAME"
    fi
    if [ ! -f "$PKG_NAME.spkg" ]; then
        echo "sage: Failed to download package $PKG_NAME from $SAGE_SERVER"
        exit 1
    fi
    PKG_SRC="`pwd`/$PKG_NAME.spkg"
    cd "$CUR"
fi

# * The -i option below to ignore checksum errors, since
#   I've had problems with this on Solaris.
# * The m option avoids clock skew problems.

echo "Extracting package $PKG_SRC ..."
ls -l "$PKG_SRC"

if [ -d "$PKG_NAME" ]; then
    echo "Removing previous version."
    rm -rf "$PKG_NAME"
fi

bunzip2 -c "$PKG_SRC" 2>/dev/null | tar fx${UNTAR_VERBOSE} -  2>/dev/null
if [ ! -d "$PKG_NAME" ]; then
    tar fx${UNTAR_VERBOSE} "$PKG_SRC"
fi
echo "Finished extraction"

if [ ! -d "$PKG_NAME" ]; then
    echo "sage: After decompressing the directory $PKG_NAME does not exist"
    echo "This means that the corresponding .spkg needs to be downloaded"
    echo "again."
    if [ -n "`no_version "$PKG_NAME"`" ]; then
        echo "Searching for latest version of $PKG_NAME"
        PKG_NAME=`sage-latest-online-package "$PKG_NAME"`
        if [ $? -eq 0 ]; then
            echo "Found package $PKG_NAME"
        else
            echo "$PKG_NAME"
            exit 1
        fi
    fi
    sage-download_package "$PKG_NAME"
    echo `pwd`
    bunzip2 -c "$PKG_NAME.spkg"  | tar fx${UNTAR_VERBOSE} -
    if [ ! -d "$PKG_NAME.spkg" ]; then
        tar fx${UNTAR_VERBOSE} "$PKG_NAME.spkg"
    fi
    if [ ! -d "$PKG_NAME" ]; then
        echo "Second download resulted in a corrupted package."
        exit 1
    fi
fi

cd "$PKG_NAME"
if [ ! -f spkg-install ]; then
    echo "#!/usr/bin/env bash" > spkg-install
    echo "" >> spkg-install
    if [ -f setup.py ]; then
        echo "python setup.py install" >> spkg-install
    else
        if [ -f configure ]; then
            echo "./configure --prefix=\$SAGE_ROOT/local/" >> spkg-install
            echo "make" >> spkg-install
            echo "make install" >> spkg-install
        else
            echo "There is no spkg-install script, no setup.py, and no configure script,"
            echo "so I do not know how to install $PKG_SRC."
            exit 1
        fi
    fi
fi

chmod +x spkg-install

echo "****************************************************"
echo "Host system"
echo "uname -a:"
uname -a
if [ $? -ne 0 ]; then
    echo "Unable to determine host system information."
fi
echo "****************************************************"

echo "****************************************************"
echo "CC Version"
echo "$CC -v"
$CC -v
if [ $? -ne 0 ]; then
    echo "Unable to determine C compiler version."
fi
echo "****************************************************"


##################################################################
# If spkg-install is a Python script, verify that the Sage Python
# has already been installed.
##################################################################
# Check the first line of the file for the string "python".
head -1 spkg-install | grep python > /dev/null
if [ $? -eq 0 ]; then   # if it is found, then the exit code will be 0
    if [ ! -f "$SAGE_LOCAL"/bin/python ]; then   # now check if the python program is in local/bin/
         # if so, exit with an error.
         echo "The spkg-install script depends on the Sage Python package,"
         echo "but the Sage Python package is not yet installed.  This may be"
         echo "a bug in the Sage build system dependency file.  Please"
         echo "update the $SAGE_ROOT/spkg/standard/deps makefile."
         exit 1
    fi
fi

BASEDIR=`pwd`
if [ -n "$DEBIAN_RELEASE" ]; then
    SAGE_CHECK=''
    if [ -e ./spkg-debian ]; then
        time ./spkg-debian
    else
        time sage-build-debian $BASEDIR
    fi
else
    time ./spkg-install
fi

if [ $? -eq 0 ]; then
    cd $INSTALLED
    # TURNED OFF: Remove all old packages with the same name up to the first "-":
    # rm -f $PKG_BASE-*

    # Mark that the new package has been installed.
    # This file will eventually be a certificate like in OS X.
    echo "PACKAGE NAME: $PKG_NAME" > "$PKG_NAME"
    echo "INSTALL DATE: `date`" >> "$PKG_NAME"
    echo "UNAME: `uname -a`" >> "$PKG_NAME"
    if [ -f "$SAGE_ROOT"/VERSION.txt ]; then
        cat "$SAGE_ROOT"/VERSION.txt >> "$PKG_NAME"
    fi
    echo "Successfully installed $PKG_NAME"

    cd $BASEDIR
    if [ "x$SAGE_CHECK" = "xyes" -a -f spkg-check ]; then
        echo "Running the test suite."
        chmod +x spkg-check
        ./spkg-check
        if [ $? -ne 0 ]; then
            rm -f $SAGE_ROOT/spkg/installed/$PKG_NAME
            error_msg "Error testing package $PKG_NAME" "make check"
            exit 1
        else
            echo "TEST SUITE: passed" >> "$INSTALLED/$PKG_NAME"
        fi
    fi


    # Delete the temporary build directory if required.
    if [ $DELETE_TMP -eq 1 ]; then
        echo "Now cleaning up tmp files."
        if [ -d "$SAGE_PACKAGES/build/$PKG_NAME" ]; then
            # the if is there only to avoid the possibility of a weird bug.
            cd "$SAGE_PACKAGES/build/"
            rm -rf "$SAGE_PACKAGES/build/$PKG_NAME"
        fi
    else
        echo "You can safely delete the temporary build directory"
        echo "$SAGE_PACKAGES/build/$PKG_NAME"
    fi

else
    error_msg "Error installing package $PKG_NAME" "make"
    exit 1
fi


# 'sage-make_relative' is currently a Python script.
# Only run it if Sage's Python is already installed (cf. #9992) and if
# sage_scripts (which includes sage-make_relative) is installed.
# This must be run from the directory SAGE_LOCAL/bin
cd "$SAGE_LOCAL/bin"
if [ -x ./python -a -f sage-make_relative ]; then
    echo "Making Python scripts relocatable..."
    ./python sage-make_relative
fi

echo "Finished installing $PKG_NAME.spkg"

exit 0
