#!/usr/bin/env python

TIMEOUT = 90

import os, re, sys, signal, time

argv = sys.argv

import sage.misc.preparser
import sage.misc.misc


SAGE_ROOT=os.environ["SAGE_ROOT"]
LD = os.environ["LD_LIBRARY_PATH"]
os.environ["LD_LIBRARY_PATH"] = SAGE_ROOT + "/local/lib:" + LD
os.environ["PYTHONPATH"]=SAGE_ROOT + "/local/lib/python/site-packages"

PYTHON = SAGE_ROOT + "/local/bin/python"

TEST_CODE= """
if __name__ ==  '__main__':
    import doctest, sys
    s = doctest.testmod(sys.modules[__name__],
                   optionflags=doctest.NORMALIZE_WHITESPACE)
    quit_sage(verbose=False)
"""

ALARM = """
import signal
def __mysig__(a,b):
    print "TIME OUT TIME OUT TIME OUT"
    raise RuntimeError, "timeout"
signal.signal(signal.SIGALRM, __mysig__)
signal.alarm(%s)
"""%TIMEOUT

NONE=0; LONG_TIME=1; RANDOM=2; OPTIONAL=3; NOT_IMPLEMENTED=4

def comment_modifier(s):
    L = s.lower()
    if ('optional' in L) or ('known bug' in L):
        return OPTIONAL
    elif 'long time' in L:
        return LONG_TIME
    elif 'todo: not implemented' in L:
        return NOT_IMPLEMENTED
    elif 'random' in L:
        return RANDOM
    return NONE

def preparse_line_with_prompt(L):
    i = L.find(':')
    if i == -1:
        return sage.misc.preparser.preparse(L)
    else:
        return L[:i+1] + sage.misc.preparser.preparse(L[i+1:])

def doc_preparse(s):
    """
    Run the preparser on the documentation string s.
    This *only* preparses the input lines, i.e., those
    that begin with "sage:".or with "...:"
    """
    sl = s.lower()

    if not optional and sl.find("optional") != -1 and \
               sl.find('package') != -1 and sl.find('installed'):
        return ''

    # This messes up the tex backslashes, so we don't do it.
    #i = s.find('\\')
    #while i != -1:
    #    j = s[i:].find('\n')
    #    s = s[:i] + s[i+j+1:]
    #    i = s.find('\\')

    # Deal with code whose output should be ignored.
    s = s.replace("sage.:", "\nsage.:")
    t = []
    for L in s.split('\n'):
        begin = L.lstrip()[:5]
        if begin == 'sage:':
            c = comment_modifier(L)
            line = ''
            if c == LONG_TIME:
                if long_time:
                    line = preparse_line_with_prompt(L)
                else:
                    line = '\n'  # extra line so output ignored
            elif c == RANDOM:
                if L.find("=") == -1 and L.find("print") == -1:
                    L = L.replace('sage:', 'sage: _=')
                line = preparse_line_with_prompt(L) + '\n'   # extra line so output ignored
            elif c == NOT_IMPLEMENTED:
                line = '\n'   # not tested
            elif c == OPTIONAL:
                if optional:
                    line = preparse_line_with_prompt(L)
                else:
                    line = '\n'
            else:
                line = preparse_line_with_prompt(L)
            t.append(line)

        elif begin[:3] == '...':
            t.append(preparse_line_with_prompt(L))
        else:
            t.append(L)
    return '\n'.join(t)

def extract_doc(file_name, module):
    a = os.path.abspath(file_name)
    i = a.rfind("sage/")
    #module_name = a[i:].replace("/",".")
    #j = module_name.rfind(".")
    #module_name = module_name[:j]

    F = open(file_name).read()
    # Put line numbers on every input line
    v = []
    i = 1
    for L in F.split('\n'):
        if L.lstrip()[:5] == 'sage:':
            #L += '\t\t#<--- "LINE %s of %s"'%(i, file_name)
            L += '###_sage"line %s:_sage_    %s_sage"'%(i, L[4:].strip())
        i += 1
        v.append(L)

    # 32/64-bit.  If we're on a 32-bit computer, remove all lines that
    # contains "# 64-bit", and if we're on a 64-bit machine remove all
    # lines that contain "# 32-bit".  This makes it possible to have
    # different output in the doctests for different bit machines.

    if sage.misc.misc.is_64bit():
        exclude_string = "# 32-bit"
    else:
        exclude_string = "# 64-bit"

    F = '\n'.join([L for L in v if not exclude_string in L])

    if sage.misc.misc.is_64bit():
        F = F.replace('# 64-bit','')
    else:
        F = F.replace('# 32-bit','')

    F = F.replace('\'"""\'','')

    if file_name[-4:] == ".tex":
        F = pythonify(F)

    n = 0
    i = 0
    s = ALARM
    s +=  "from sage.all import *\n"

    while True:
        i = F.find('"""')
        if i == -1: break
        k = F[i+3].find('"""')
        j = i+3 + F[i+3:].find('"""')
        s += "def example%s():"%n
        n += 1
        s += "\tr"+doc_preparse(F[i:j+3]) + "\n\n"
        F = F[j+3:]

    i = F.find('def __doctest_cleanup')
    if i != -1:
        s += F[i:] + '\n'
        s += TEST_CODE
        s += '    __doctest_cleanup()\n'
    else:
        s += TEST_CODE
    s += '    sys.exit(s[0])'


    # Allow for "sage:" instead of the traditional Python ">>>".
    s = s.replace("sage:",">>>").replace('_sage"','')

    return s

def pythonify(F):
    """
    INPUT:
        F -- string; read in latex file
    OUTPUT:
        string -- python program that has functions with docstrings made from the
                  verbatim examples in the latex file.
    """
    # Close links:
    F = F.replace('\\end{verbatim}%link','')
    F = F.replace('%link\n\\begin{verbatim}','')

    # Get rid of skipped code
    s = ''
    while True:
        i = F.find('%skip')
        if i == -1:
            s += F
            break
        s += F[:i]
        F = F[i:]
        j = F.find('\\end{verbatim}')
        if j == -1:
            break
        F = F[j + len('\\end{verbatim}')+1:]
    F = s

    # Make the verbatim environ's get extracted via the usual parser above
    F = F.replace("\\begin{verbatim}",'"""')
    F = F.replace("\\end{verbatim}",'"""')
    return F

def post_process(s):
    s = s.replace('.doctest/','')
    i = s.find("Failed example:")
    cnt = 0
    while i != -1:
        k = s[:i].rfind('File')
        k += s[k:].find(',')
        j = s[i:].find('###line')
        s = s[:k] + ', ' + s[i+j+3:]
        i = s.find("Failed example:")
        cnt += 1
        if cnt > 1000:
            break
    s = s.replace(':_sage_',':\n').replace('>>>','sage:')
    c = '###line [0-9]*\n'
    r = re.compile(c)
    s = r.sub('\n',s)
    return s

__alarm_time=0
def __mysig(a,b):
    raise RuntimeError, "computation timed out because alarm was set for %s seconds"%__alarm_time

def alarm(seconds):
    """
    Raise a KeyboardInterrupt exception in a given number of seconds.
    This is useful for automatically interrupting long computations
    and can be trapped using exception handling.

    INPUT:
        seconds -- integer
    """
    seconds = int(seconds)
    # Set our alarm signal handler.
    signal.signal(signal.SIGALRM, __mysig)
    global __alarm_time
    __alarm_time = seconds
    signal.alarm(seconds)

def test_file(file):
    if os.path.exists(file):
        name = os.path.basename(file)
        name = name[:name.find(".")]
        s = extract_doc(file, name)
        f = ".doctest/%s.py"%name
        #f = "__test_%s.py"%name
        if not os.path.exists(".doctest"):
            os.makedirs(".doctest")
        open(f,"w").write(s)
        cmd = "%s %s"%(PYTHON, f)
        #n = os.system(cmd)
        tm = time.time()
        try:
            os.system("%s 1>.doctest/out 2>.doctest/err"%cmd)
            out = open('.doctest/out').read()
            err = open('.doctest/err').read()
        except KeyboardInterrupt:
            err += "\n Error -- interrupted after %s seconds!"%tm
            print "Error!!!"

        if time.time() - tm >= TIMEOUT:
            err = "*** *** Error: TIMED OUT! *** ***"
            print err

        s = post_process(out)  + err
        print s
        if 'Failed' in s or 'Error' in s:
            sage.misc.misc.delete_tmpfiles()
            sys.exit(1)
        else:
            sage.misc.misc.delete_tmpfiles()
            sys.exit(0)
    else:
        print "Error running %s, since file %s does not exist."%(
            argv[0], argv[1])
        sage.misc.misc.delete_tmpfiles()
        sys.exit(1)


def has_opt(opt):
    try:
        i = argv.index(opt)
        del argv[i]
        return True
    except ValueError:
        return False



if __name__ ==  '__main__':
    import os, sys
    if len(argv) == 1:
        print "Usage: %s [-optional] [-long] <filename.py | filename.pyx>"%(argv[0])
        print "If -optional is present include examples that uses optional packages."
        print "If -long is present include examples that take a long time to run,"
        print 'which is defined by the input line containing the phrase "long time".'

    else:
        optional = has_opt('-optional')
        long_time = has_opt('-long')
        test_file(argv[1])
