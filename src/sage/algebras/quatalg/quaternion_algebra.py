"""
Quaternion Algebras

AUTHORS:

- Jon Bobber -- 2009 rewrite

- William Stein -- 2009 rewrite

This code is partly based on Sage code by David Kohel from 2005.

TESTS:

We test pickles::

    sage: Q.<i,j,k> = QuaternionAlgebra(QQ,-5,-2)
    sage: Q == loads(dumps(Q))
    True
"""

########################################################################
#       Copyright (C) 2009 William Stein <wstein@gmail.com>
#       Copyright (C) 2009 Jonathon Bober <jwbober@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/
########################################################################


from sage.rings.arith import (GCD, fundamental_discriminant, hilbert_symbol,
                              hilbert_conductor_inverse, hilbert_conductor,
                              factor, gcd, lcm)
from sage.rings.integer import Integer
from sage.rings.integer_ring import ZZ
from sage.rings.rational import Rational

from sage.rings.ring import Algebra, is_Field
from sage.rings.ideal import Ideal_fractional
from sage.rings.rational_field import is_RationalField, QQ
from sage.rings.number_field.number_field import is_NumberField
from sage.structure.parent_gens import ParentWithGens, normalize_names
from sage.matrix.matrix_space import MatrixSpace
from sage.matrix.constructor import diagonal_matrix, matrix
from sage.structure.sequence import Sequence
from sage.structure.element import is_Element
from sage.modules.free_module import VectorSpace, FreeModule
from sage.modules.free_module_element import vector

import quaternion_algebra_element
import quaternion_algebra_cython

########################################################
# Constructor
########################################################

_cache = {}

def QuaternionAlgebra(arg0, arg1=None, arg2=None, names='i,j,k'):
    """
    There are three input formats:

    - ``QuaternionAlgebra(a, b)``: quaternion algebra generated by ``i``, ``j``
      subject to `i^2 = a`, `j^2 = b`, `j * i = -i * j`.

    - ``QuaternionAlgebra(K, a, b)``: same as above but over a field ``K``.
      Here, ``a`` and ``b`` are nonzero elements of a field (``K``) of
      characteristic not 2, and we set `k = i * j`.

    - ``QuaternionAlgebra(D)``: a rational quaternion algebra with
      discriminant ``D``, where `D > 1` is a squarefree integer.

    EXAMPLES:

    ``QuaternionAlgebra(a, b)`` - return quaternion algebra over the
    *smallest* field containing the nonzero elements ``a`` and ``b`` with
    generators ``i``, ``j``, ``k`` with `i^2=a`, `j^2=b` and `j*i=-i*j`::

        sage: QuaternionAlgebra(-2,-3)
        Quaternion Algebra (-2, -3) with base ring Rational Field
        sage: QuaternionAlgebra(GF(5)(2), GF(5)(3))
        Quaternion Algebra (2, 3) with base ring Finite Field of size 5
        sage: QuaternionAlgebra(2, GF(5)(3))
        Quaternion Algebra (2, 3) with base ring Finite Field of size 5
        sage: QuaternionAlgebra(QQ[sqrt(2)](-1), -5)
        Quaternion Algebra (-1, -5) with base ring Number Field in sqrt2 with defining polynomial x^2 - 2
        sage: QuaternionAlgebra(sqrt(-1), sqrt(-3))
        Quaternion Algebra (I, sqrt(-3)) with base ring Symbolic Ring
        sage: QuaternionAlgebra(0,0)
        Traceback (most recent call last):
        ...
        ValueError: a and b must be nonzero
        sage: QuaternionAlgebra(GF(2)(1),1)
        Traceback (most recent call last):
        ...
        ValueError: a and b must be elements of a field with characteristic not 2

    ``QuaternionAlgebra(K, a, b)`` - return quaternion algebra over the
    field ``K`` with generators ``i``, ``j``, ``k`` with `i^2=a`, `j^2=b`
    and `i*j=-j*i`::

        sage: QuaternionAlgebra(QQ, -7, -21)
        Quaternion Algebra (-7, -21) with base ring Rational Field
        sage: QuaternionAlgebra(QQ[sqrt(2)], -2,-3)
        Quaternion Algebra (-2, -3) with base ring Number Field in sqrt2 with defining polynomial x^2 - 2

    ``QuaternionAlgebra(D)`` - ``D`` is a squarefree integer; returns a
    rational quaternion algebra of discriminant ``D``::

        sage: QuaternionAlgebra(1)
        Quaternion Algebra (-1, 1) with base ring Rational Field
        sage: QuaternionAlgebra(2)
        Quaternion Algebra (-1, -1) with base ring Rational Field
        sage: QuaternionAlgebra(7)
        Quaternion Algebra (-1, -7) with base ring Rational Field
        sage: QuaternionAlgebra(2*3*5*7)
        Quaternion Algebra (-22, 210) with base ring Rational Field

    If the coefficients `a` and `b` in the definition of the quaternion
    algebra are not integral, then a slower generic type is used for
    arithmetic::

        sage: type(QuaternionAlgebra(-1,-3).0)
        <type 'sage.algebras.quatalg.quaternion_algebra_element.QuaternionAlgebraElement_rational_field'>
        sage: type(QuaternionAlgebra(-1,-3/2).0)
        <type 'sage.algebras.quatalg.quaternion_algebra_element.QuaternionAlgebraElement_generic'>

    Make sure caching is sane::

        sage: A = QuaternionAlgebra(2,3); A
        Quaternion Algebra (2, 3) with base ring Rational Field
        sage: B = QuaternionAlgebra(GF(5)(2),GF(5)(3)); B
        Quaternion Algebra (2, 3) with base ring Finite Field of size 5
        sage: A is QuaternionAlgebra(2,3)
        True
        sage: B is QuaternionAlgebra(GF(5)(2),GF(5)(3))
        True
        sage: Q = QuaternionAlgebra(2); Q
        Quaternion Algebra (-1, -1) with base ring Rational Field
        sage: Q is QuaternionAlgebra(QQ,-1,-1)
        True
        sage: Q is QuaternionAlgebra(-1,-1)
        True
        sage: Q.<ii,jj,kk> = QuaternionAlgebra(15); Q.variable_names()
        ('ii', 'jj', 'kk')
        sage: QuaternionAlgebra(15).variable_names()
        ('i', 'j', 'k')
    """

    # QuaternionAlgebra(D)
    if arg1 is None and arg2 is None:
        K = QQ
        D = Integer(arg0)
        a, b = hilbert_conductor_inverse(D)
        a = Rational(a); b = Rational(b)

    elif arg2 is None:
        if is_Element(arg0):
            # QuaternionAlgebra(a, b)
            v = Sequence([arg0, arg1])
            K = v.universe().fraction_field()
            a = v[0]
            b = v[1]
        else:
            raise ValueError, "unknown input"

    # QuaternionAlgebra(K, a, b)
    else:
        K = arg0
        if not is_Field(K):
            raise TypeError, "base ring of quaternion algebra must be a field"
        a = K(arg1)
        b = K(arg2)

    if K.characteristic() == 2:
        # Lameness!
        raise ValueError, "a and b must be elements of a field with characteristic not 2"
    if a == 0 or b == 0:
        raise ValueError, "a and b must be nonzero"

    global _cache
    names = normalize_names(3, names)
    key = (K, a, b, names)
    if _cache.has_key(key):
        return _cache[key]
    A = QuaternionAlgebra_ab(K, a, b, names=names)
    A._key = key
    _cache[key] = A
    return A




########################################################
# Classes
########################################################

def is_QuaternionAlgebra(A):
    """
    Return ``True`` if ``A`` is of the QuaternionAlgebra data type.

    EXAMPLES::

        sage: sage.algebras.quatalg.quaternion_algebra.is_QuaternionAlgebra(QuaternionAlgebra(QQ,-1,-1))
        True
        sage: sage.algebras.quatalg.quaternion_algebra.is_QuaternionAlgebra(ZZ)
        False
    """
    return isinstance(A, QuaternionAlgebra_abstract)

class QuaternionAlgebra_abstract(Algebra):
    def _repr_(self):
        """
        EXAMPLES::

            sage: sage.algebras.quatalg.quaternion_algebra.QuaternionAlgebra_abstract(QQ)._repr_()
            'Quaternion Algebra with base ring Rational Field'
        """
        return "Quaternion Algebra with base ring %s"%self.base_ring()

    def ngens(self):
        """
        Return the number of generators of the quaternion algebra as a K-vector
        space, not including 1.  This value is always 3: the algebra is spanned
        by the standard basis `1`, `i`, `j`, `k`.

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ,-5,-2)
            sage: Q.ngens()
            3
            sage: Q.gens()
            [i, j, k]
        """
        return 3

    def basis(self):
        """
        Return the fixed basis of ``self``, which is `1`, `i`, `j`, `k`, where
        `i`, `j`, `k` are the generators of ``self``.

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ,-5,-2)
            sage: Q.basis()
            (1, i, j, k)

            sage: Q.<xyz,abc,theta> = QuaternionAlgebra(GF(9,'a'),-5,-2)
            sage: Q.basis()
            (1, xyz, abc, theta)

        The basis is cached::

            sage: Q.basis() is Q.basis()
            True
        """
        try:
            return self.__basis
        except AttributeError:
            self.__basis = tuple([self(1)] + list(self.gens()))
            return self.__basis

    def inner_product_matrix(self):
        """
        Return the inner product matrix associated to ``self``, i.e. the
        Gram matrix of the reduced norm as a quadratic form on ``self``.
        The standard basis `1`, `i`, `j`, `k` is orthogonal, so this matrix
        is just the diagonal matrix with diagonal entries `2`, `2a`, `2b`,
        `2ab`.

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(-5,-19)
            sage: Q.inner_product_matrix()
            [  2   0   0   0]
            [  0  10   0   0]
            [  0   0  38   0]
            [  0   0   0 190]
        """
        try: return self.__inner_product_matrix
        except AttributeError: pass

        a, b = self._a, self._b
        M = diagonal_matrix(self.base_ring(), [2, -2*a, -2*b, 2*a*b])
        M.set_immutable()
        self.__inner_product_matrix = M
        return M

    def is_commutative(self):
        """
        Return ``False`` always, since all quaternion algebras are
        noncommutative.

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ, -3,-7)
            sage: Q.is_commutative()
            False
        """
        return False

    def is_division_algebra(self):
        """
        Return ``True`` if the quaternion algebra is a division algebra (i.e.
        every nonzero element in ``self`` is invertible), and ``False`` if the
        quaternion algebra is isomorphic to the 2x2 matrix algebra.

        EXAMPLES::

            sage: QuaternionAlgebra(QQ,-5,-2).is_division_algebra()
            True
            sage: QuaternionAlgebra(1).is_division_algebra()
            False
            sage: QuaternionAlgebra(2,9).is_division_algebra()
            False
            sage: QuaternionAlgebra(RR(2.),1).is_division_algebra()
            Traceback (most recent call last):
            ...
            NotImplementedError: base field must be rational numbers
        """
        return self.discriminant() != 1

    def is_matrix_ring(self):
        """
        Return ``True`` if the quaternion algebra is isomorphic to the 2x2
        matrix ring, and ``False`` if ``self`` is a division algebra (i.e.
        every nonzero element in ``self`` is invertible).

        EXAMPLES::

            sage: QuaternionAlgebra(QQ,-5,-2).is_matrix_ring()
            False
            sage: QuaternionAlgebra(1).is_matrix_ring()
            True
            sage: QuaternionAlgebra(2,9).is_matrix_ring()
            True
            sage: QuaternionAlgebra(RR(2.),1).is_matrix_ring()
            Traceback (most recent call last):
            ...
            NotImplementedError: base field must be rational numbers

        """
        return self.discriminant() == 1

    def is_exact(self):
        """
        Return ``True`` if elements of this quaternion algebra are represented
        exactly, i.e. there is no precision loss when doing arithmetic. A
        quaternion algebra is exact if and only if its base field is
        exact.

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ, -3, -7)
            sage: Q.is_exact()
            True
            sage: Q.<i,j,k> = QuaternionAlgebra(Qp(7), -3, -7)
            sage: Q.is_exact()
            False
        """
        return self.base_ring().is_exact()

    def is_field(self):
        """
        Return ``False`` always, since all quaternion algebras are
        noncommutative and all fields are commutative.

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ, -3, -7)
            sage: Q.is_field()
            False
        """
        return False

    def is_finite(self):
        """
        Return ``True`` if the quaternion algebra is finite as a set.

        Algorithm: A quaternion algebra is finite if and only if the
        base field is finite.

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ, -3, -7)
            sage: Q.is_finite()
            False
            sage: Q.<i,j,k> = QuaternionAlgebra(GF(5), -3, -7)
            sage: Q.is_finite()
            True
        """
        return self.base_ring().is_finite()

    def is_integral_domain(self):
        """
        Return ``False`` always, since all quaternion algebras are
        noncommutative and integral domains are commutative (in Sage).

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ, -3, -7)
            sage: Q.is_integral_domain()
            False
        """
        return False

    def is_noetherian(self):
        """
        Return ``True`` always, since any quaternion algebra is a noetherian
        ring (because it is a finitely generated module over a field).

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ, -3, -7)
            sage: Q.is_noetherian()
            True
        """
        return True

    def order(self):
        """
        Return the number of elements of the quaternion algebra, or
        ``+Infinity`` if the algebra is not finite.

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ, -3, -7)
            sage: Q.order()
            +Infinity
            sage: Q.<i,j,k> = QuaternionAlgebra(GF(5), -3, -7)
            sage: Q.order()
            625
        """
        return (self.base_ring().order())**4

    def random_element(self, *args, **kwds):
        """
        Return a random element of this quaternion algebra.

        The ``args`` and ``kwds`` are passed to the ``random_element`` method
        of the base ring.

        EXAMPLES::

            sage: QuaternionAlgebra(QQ[sqrt(2)],-3,7).random_element()
            -4 + (-1/95*sqrt2 - 1/2)*i + (-12*sqrt2 + 1/2)*j + (1/2*sqrt2 - 1)*k
            sage: QuaternionAlgebra(-3,19).random_element()
            -1/4 + 2/3*i - 5/2*j
            sage: QuaternionAlgebra(GF(17)(2),3).random_element()
            11 - i + 4*j + 13*k

        Specify the numerator and denominator bounds::

            sage: QuaternionAlgebra(-3,19).random_element(10^6,10^6)
            -61003/263835 + 222181/103881*i - 7314/2707*j + 458453/129132*k
        """
        K = self.base_ring()
        return self([ K.random_element(*args, **kwds) for _ in range(4) ])

    def vector_space(self):
        """
        Return the vector space associated to ``self`` with inner product given
        by the reduced norm.

        EXAMPLES::

            sage: QuaternionAlgebra(-3,19).vector_space()
            Ambient quadratic space of dimension 4 over Rational Field
            Inner product matrix:
            [   2    0    0    0]
            [   0    6    0    0]
            [   0    0  -38    0]
            [   0    0    0 -114]
        """
        try:
            return self.__vector_space
        except AttributeError:
            V = VectorSpace(self.base_ring(), 4, inner_product_matrix = self.inner_product_matrix())
            self.__vector_space = V
            return V


class QuaternionAlgebra_ab(QuaternionAlgebra_abstract):
    """
    The quaternion algebra of the form `(a, b/K)`, where `i^2=a`, `j^2 = b`,
    and `j*i = -i*j`.  ``K`` is a field not of characteristic 2 and ``a``,
    ``b`` are nonzero elements of ``K``.

    See ``QuaternionAlgebra`` for many more examples.

    EXAMPLES::

        sage: QuaternionAlgebra(QQ, -7, -21)  # indirect doctest
        Quaternion Algebra (-7, -21) with base ring Rational Field
    """
    def __init__(self, base_ring, a, b, names='i,j,k'):
        """
        Create the quaternion algebra with `i^2 = a`, `j^2 = b`, and
        `i*j = -j*i = k`.

        INPUT:

        - ``base_ring`` - commutative ring
        - ``a, b`` - elements of ``base_ring``
        - ``names`` - string (optional, default 'i, j, k') names of the generators

        TESTS::

        Test making quaternion elements (using the element constructor)::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ,-1,-2)
            sage: a = Q(2/3); a
            2/3
            sage: type(a)
            <type 'sage.algebras.quatalg.quaternion_algebra_element.QuaternionAlgebraElement_rational_field'>
            sage: Q(a)
            2/3
            sage: Q([1,2,3,4])
            1 + 2*i + 3*j + 4*k
            sage: Q((1,2,3,4))
            1 + 2*i + 3*j + 4*k
            sage: Q(-3/5)
            -3/5

        The base ring must be a field::

            sage: Q.<ii,jj,kk> = QuaternionAlgebra(ZZ,-5,-19)
            Traceback (most recent call last):
            ...
            TypeError: base ring of quaternion algebra must be a field
        """
        ParentWithGens.__init__(self, base_ring, names=names)
        self._a = a
        self._b = b
        if not is_Field(base_ring):
            raise TypeError, "base ring of quaternion algebra must be a field"
        if is_RationalField(base_ring) and a.denominator() == 1 and b.denominator() == 1:
            element_constructor = quaternion_algebra_element.QuaternionAlgebraElement_rational_field
        elif is_NumberField(base_ring) and base_ring.degree() > 2 and base_ring.is_absolute() and \
                 a.denominator() == 1 and b.denominator() == 1 and base_ring.defining_polynomial().is_monic():
            # This QuaternionAlgebraElement_number_field class is not
            # designed to work with elements of a quadratic field.  To
            # do that, the main thing would be to implement
            # __getitem__, etc.  This would maybe give a factor of 2
            # (or more?) speedup.  Much care must be taken because the
            # underlying representation of quadratic fields is a bit
            # tricky.
            element_constructor = quaternion_algebra_element.QuaternionAlgebraElement_number_field
        else:
            element_constructor = quaternion_algebra_element.QuaternionAlgebraElement_generic
        self._populate_coercion_lists_(coerce_list=[base_ring], element_constructor=element_constructor)
        self._gens = [self([0,1,0,0]), self([0,0,1,0]), self([0,0,0,1])]

    def maximal_order(self):
        """
        Return a maximal order in this quaternion algebra.

        OUTPUT: an order in this quaternion algebra

        EXAMPLES::

            sage: QuaternionAlgebra(-1,-7).maximal_order()
            Order of Quaternion Algebra (-1, -7) with base ring Rational Field with basis (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
        """
        try: return self.__maximal_order
        except AttributeError: pass
        if self.base_ring() == QQ and self.discriminant().is_prime():
            from sage.modular.quatalg.brandt import maximal_order
            R = maximal_order(self)
            self.__maximal_order = R
            return R
        raise NotImplementedError, "maximal order only implemented for rational quaternion algebras of prime discriminant"

    def invariants(self):
        """
        Return the structural invariants `a`, `b` of this quaternion
        algebra: ``self`` is generated by `i`, `j` subject to
        `i^2 = a`, `j^2 = b` and `j*i = -i*j`.

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(15)
            sage: Q.invariants()
            (-3, 5)
            sage: i^2
            -3
            sage: j^2
            5
        """
        return self._a, self._b

    def __cmp__(self, other):
        """
        Compare self and other.

        EXAMPLES::

            sage: cmp(QuaternionAlgebra(-1,-7), QuaternionAlgebra(-1,-7))
            0
            sage: cmp(QuaternionAlgebra(-1,-7), QuaternionAlgebra(-1,-5))
            -1
            sage: cmp(QuaternionAlgebra(-1,-7), QuaternionAlgebra(-1,-10))
            1
        """
        if not isinstance(other, QuaternionAlgebra_abstract):
            return cmp(type(self), type(other))
        c = cmp(self.base_ring(), other.base_ring())
        if c: return c
        return cmp((self._a, self._b), (other._a, other._b))

    def __reduce__(self):
        """
        Internal method used for pickling.

        TESTS::

            sage: QuaternionAlgebra(QQ,-1,-2).__reduce__()
            (<function unpickle_QuaternionAlgebra_v0 at ...>, (Rational Field, -1, -2, ('i', 'j', 'k')))

        Test uniqueness of parent::

            sage: Q = QuaternionAlgebra(QQ,-1,-2)
            sage: loads(dumps(Q)) is Q
            True
        """
        return unpickle_QuaternionAlgebra_v0, self._key

    def gen(self, i=0):
        """
        Return the `i^{th}` generator of ``self``.

        INPUT:

        - ``i`` - integer (optional, default 0)

        EXAMPLES::

            sage: Q.<ii,jj,kk> = QuaternionAlgebra(QQ,-1,-2); Q
            Quaternion Algebra (-1, -2) with base ring Rational Field
            sage: Q.gen(0)
            ii
            sage: Q.gen(1)
            jj
            sage: Q.gen(2)
            kk
            sage: Q.gens()
            [ii, jj, kk]
        """
        return self._gens[i]

    def _repr_(self):
        """
        Print representation.

        TESTS::

            sage: Q.<i,j,k> = QuaternionAlgebra(QQ,-5,-2)
            sage: type(Q)
            <class 'sage.algebras.quatalg.quaternion_algebra.QuaternionAlgebra_ab'>
            sage: Q._repr_()
            'Quaternion Algebra (-5, -2) with base ring Rational Field'
            sage: Q
            Quaternion Algebra (-5, -2) with base ring Rational Field
            sage: print Q
            Quaternion Algebra (-5, -2) with base ring Rational Field
            sage: str(Q)
            'Quaternion Algebra (-5, -2) with base ring Rational Field'
        """
        return "Quaternion Algebra (%r, %r) with base ring %s"%(self._a, self._b, self.base_ring())

    def inner_product_matrix(self):
        """
        Return the inner product matrix associated to ``self``, i.e. the
        Gram matrix of the reduced norm as a quadratic form on ``self``.
        The standard basis `1`, `i`, `j`, `k` is orthogonal, so this matrix
        is just the diagonal matrix with diagonal entries `1`, `a`, `b`, `ab`.

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(-5,-19)
            sage: Q.inner_product_matrix()
            [  2   0   0   0]
            [  0  10   0   0]
            [  0   0  38   0]
            [  0   0   0 190]

            sage: R.<a,b> = QQ[]; Q.<i,j,k> = QuaternionAlgebra(Frac(R),a,b)
            sage: Q.inner_product_matrix()
            [    2     0     0     0]
            [    0  -2*a     0     0]
            [    0     0  -2*b     0]
            [    0     0     0 2*a*b]
        """
        a, b = self._a, self._b
        return diagonal_matrix(self.base_ring(), [2, -2*a, -2*b, 2*a*b])

    def discriminant(self):
        """
        Given a quaternion algebra `A` defined over the field of
        rational numbers, return the discriminant of `A`, i.e. the
        product of the ramified primes of `A`.

        EXAMPLES::

            sage: QuaternionAlgebra(210,-22).discriminant()
            210
            sage: QuaternionAlgebra(19).discriminant()
            19

        This raises a ``NotImplementedError`` if the base field is not
        the rational numbers::

            sage: QuaternionAlgebra(QQ[sqrt(2)],3,19).discriminant()
            Traceback (most recent call last):
            ...
            NotImplementedError: base field must be rational numbers
        """
        try: return self.__discriminant
        except AttributeError: pass
        if not is_RationalField(self.base_ring()):
            raise NotImplementedError, "base field must be rational numbers"
        self.__discriminant = hilbert_conductor(self._a, self._b)
        return self.__discriminant

    def ramified_primes(self):
        """
        Return the primes that ramify in this quaternion algebra. Currently
        only implemented over the rational numbers.

        EXAMPLES::

            sage: QuaternionAlgebra(QQ, -1, -1).ramified_primes()
            [2]
        """
            #TODO: more examples

        return [f[0] for f in factor(self.discriminant())]

    def _magma_init_(self, magma):
        """
        Return Magma version of this quaternion algebra.

        EXAMPLES::

            sage: Q = QuaternionAlgebra(-1,-1); Q
            Quaternion Algebra (-1, -1) with base ring Rational Field
            sage: Q._magma_init_(magma)                                  # optional - magma
            'QuaternionAlgebra(_sage_[1],-1,-1)'
            sage: A = magma(Q); A                                        # optional - magma
            Quaternion Algebra with base ring Rational Field
            sage: A.RamifiedPlaces()                                     # optional - magma
            [
            Ideal of Integer Ring generated by 2
            ]

        A more complicated example involving a quaternion algebra over a number field::

            sage: K.<a> = QQ[sqrt(2)]; Q = QuaternionAlgebra(K,-1,a); Q
            Quaternion Algebra (-1, sqrt2) with base ring Number Field in sqrt2 with defining polynomial x^2 - 2
            sage: magma(Q)                                              # optional - magma
            Quaternion Algebra with base ring Number Field with defining polynomial x^2 - 2 over the Rational Field
            sage: Q._magma_init_(magma)                                 # optional - magma
            'QuaternionAlgebra(_sage_[...],(_sage_[...]![-1, 0]),(_sage_[...]![0, 1]))'
        """
        R = magma(self.base_ring())
        return 'QuaternionAlgebra(%s,%s,%s)'%(R.name(),
                                              self._a._magma_init_(magma),
                                              self._b._magma_init_(magma))

    def quaternion_order(self, basis, check=True):
        """
        Return the order of this quaternion order with given basis.

        INPUT:

        - ``basis`` - list of 4 elements of ``self``
        - ``check`` - bool (default: ``True``)

        EXAMPLES::

            sage: Q.<i,j,k> = QuaternionAlgebra(-11,-1)
            sage: Q.quaternion_order([1,i,j,k])
            Order of Quaternion Algebra (-11, -1) with base ring Rational Field with basis (1, i, j, k)

        We test out ``check=False``::

            sage: Q.quaternion_order([1,i,j,k], check=False)
            Order of Quaternion Algebra (-11, -1) with base ring Rational Field with basis [1, i, j, k]
            sage: Q.quaternion_order([i,j,k], check=False)
            Order of Quaternion Algebra (-11, -1) with base ring Rational Field with basis [i, j, k]
        """
        return QuaternionOrder(self, basis, check=check)

    def ideal(self, gens, left_order=None, right_order=None, check=True):
        r"""
        Return the quaternion ideal with given gens over `\ZZ`.
        Neither a left or right order structure need be specified.

        INPUT:

        - ``gens`` -- a list of elements of this quaternion order

        - ``check`` -- bool (default: ``True``); if ``False``, then ``gens`` must
          4-tuple that forms a Hermite basis for an ideal

        - ``left_order`` -- a quaternion order or ``None``

        - ``right_order`` -- a quaternion order or ``None``

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1)
            sage: R.ideal([2*a for a in R.basis()])
            Fractional ideal (2, 2*i, 2*j, 2*k)
        """
        if self.base_ring() == QQ:
            return QuaternionFractionalIdeal_rational(gens, left_order=left_order, right_order=right_order, check=check)
        else:
            raise NotImplementedError, "ideal only implemented for quaternion algebras over QQ"

############################################################
# Unpickling
############################################################
def unpickle_QuaternionAlgebra_v0(*key):
    """
    The 0th version of pickling for quaternion algebras.

    EXAMPLES::

        sage: Q = QuaternionAlgebra(-5,-19)
        sage: f, t = Q.__reduce__()
        sage: sage.algebras.quatalg.quaternion_algebra.unpickle_QuaternionAlgebra_v0(*t)
        Quaternion Algebra (-5, -19) with base ring Rational Field
        sage: loads(dumps(Q)) == Q
        True
        sage: loads(dumps(Q)) is Q
        True
    """
    return QuaternionAlgebra(*key)


class QuaternionOrder(Algebra):
    """
    An order in a quaternion algebra.

    EXAMPLES::

        sage: QuaternionAlgebra(-1,-7).maximal_order()
        Order of Quaternion Algebra (-1, -7) with base ring Rational Field with basis (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
        sage: type(QuaternionAlgebra(-1,-7).maximal_order())
        <class 'sage.algebras.quatalg.quaternion_algebra.QuaternionOrder'>
    """
    def __init__(self, A, basis, check=True):
        """
        INPUT:

        - ``A`` - a quaternion algebra
        - ``basis`` - list of 4 integral quaternions in ``A``
        - ``check`` - whether to do type and other consistency checks

        ** TODO -- NOTE: We do *not* currently check that basis is
           closed under multiplication!! **

        EXAMPLES::

            sage: A.<i,j,k> = QuaternionAlgebra(-3,-5)
            sage: sage.algebras.quatalg.quaternion_algebra.QuaternionOrder(A, [1,i,j,k])
            Order of Quaternion Algebra (-3, -5) with base ring Rational Field with basis (1, i, j, k)
            sage: R = sage.algebras.quatalg.quaternion_algebra.QuaternionOrder(A, [1,2*i,2*j,2*k]); R
            Order of Quaternion Algebra (-3, -5) with base ring Rational Field with basis (1, 2*i, 2*j, 2*k)
            sage: type(R)
            <class 'sage.algebras.quatalg.quaternion_algebra.QuaternionOrder'>
        """
        if check:
            # right data type
            if not isinstance(basis, (list, tuple)):
                raise TypeError, "basis must be a list or tuple"
            # right length
            if len(basis) != 4:
                raise ValueError, "basis must have length 4"
            # coerce to common parent
            basis = tuple([A(x) for x in basis])
        self.__basis = basis
        self.__quaternion_algebra = A
        ParentWithGens.__init__(self, ZZ, names=None)

    def gens(self):
        """
        Return generators for self.

        EXAMPLES::

            sage: QuaternionAlgebra(-1,-7).maximal_order().gens()
            (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
        """
        return self.__basis

    def ngens(self):
        """
        Return the number of generators (which is 4).

        EXAMPLES::

            sage: QuaternionAlgebra(-1,-7).maximal_order().ngens()
            4
        """
        return 4

    def gen(self, n):
        """
        Return the n-th generator.

        INPUT:

        - ``n`` - an integer between 0 and 3, inclusive.

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1).maximal_order(); R
            Order of Quaternion Algebra (-11, -1) with base ring Rational Field with basis (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
            sage: R.gen(0)
            1/2 + 1/2*j
            sage: R.gen(1)
            1/2*i + 1/2*k
            sage: R.gen(2)
            j
            sage: R.gen(3)
            k
        """
        return self.__basis[n]

    def __cmp__(self, R):
        """
        Compare orders self and other.  Two orders are equal if they
        have the same basis and are in the same quaternion algebra.

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1).maximal_order()
            sage: R == R                       # indirect doctest
            True
            sage: R == QuaternionAlgebra(-13,-1).maximal_order()
            False
            sage: R==5
            False
        """
        if not isinstance(R, QuaternionOrder):
            return cmp(type(self), type(R))
        c = cmp(self.__quaternion_algebra, R.__quaternion_algebra)
        if c: return c
        return cmp(self.__basis, R.__basis)


    def basis(self):
        """
        Return fix choice of basis for this quaternion order.

        EXAMPLES::

            sage: QuaternionAlgebra(-11,-1).maximal_order().basis()
            (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
        """
        return self.__basis

    def quaternion_algebra(self):
        """
        Return ambient quaternion algebra that contains this quaternion order.

        EXAMPLES::

            sage: QuaternionAlgebra(-11,-1).maximal_order().quaternion_algebra()
            Quaternion Algebra (-11, -1) with base ring Rational Field
        """
        return self.__quaternion_algebra

    def _repr_(self):
        """
        Return string representation of this order.

        EXAMPLES::

            sage: QuaternionAlgebra(-11,-1).maximal_order()._repr_()
            'Order of Quaternion Algebra (-11, -1) with base ring Rational Field with basis (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)'
            sage: QuaternionAlgebra(-11,-1).maximal_order()
            Order of Quaternion Algebra (-11, -1) with base ring Rational Field with basis (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
        """
        return 'Order of %s with basis %s'%(self.quaternion_algebra(), self.basis())

    def random_element(self, *args, **kwds):
        """
        Return a random element of this order.

        The args and kwds are passed to the random_element method of
        the integer ring, and we return an element of the form

        .. math::

            ae_1 + be_2 + ce_3 + de_4

        where `e_1`, ..., `e_4` are the basis of this order and `a`,
        `b`, `c`, `d` are random integers.

        EXAMPLES::

            sage: QuaternionAlgebra(-11,-1).maximal_order().random_element()
            -4 + i - 4*j + k
            sage: QuaternionAlgebra(-11,-1).maximal_order().random_element(-10,10)
            -9/2 - 7/2*i - 7/2*j + 3/2*k
        """
        return sum( (ZZ.random_element(*args, **kwds) * b for b in self.basis()) )

    def intersection(self, other):
        """
        Return the intersection of this order with other.

        INPUT:

        - ``other`` - a quaternion order in the same ambient quaternion algebra

        OUTPUT: a quaternion order

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1).maximal_order()
            sage: R.intersection(R)
            Order of Quaternion Algebra (-11, -1) with base ring Rational Field with basis (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)

        We intersect various orders in the quaternion algebra ramified at 11::

            sage: B = BrandtModule(11,3)
            sage: R = B.maximal_order(); S = B.order_of_level_N()
            sage: R.intersection(S)
            Order of Quaternion Algebra (-1, -11) with base ring Rational Field with basis (1/2 + 1/2*j, 1/2*i + 5/2*k, j, 3*k)
            sage: R.intersection(S) == S
            True
            sage: B = BrandtModule(11,5)
            sage: T = B.order_of_level_N()
            sage: S.intersection(T)
            Order of Quaternion Algebra (-1, -11) with base ring Rational Field with basis (1/2 + 1/2*j, 1/2*i + 23/2*k, j, 15*k)
        """
        if not isinstance(other, QuaternionOrder):
            raise TypeError, "other must be a QuaternionOrder"

        A = self.quaternion_algebra()
        if other.quaternion_algebra() != A:
            raise ValueError, "self and other must be in the same ambient quaternion algebra"

        V = A.base_ring()**4

        B = V.span([V(list(g)) for g in self.basis()], ZZ)
        C = V.span([V(list(g)) for g in other.basis()], ZZ)

        # todo -- A(list(e)) could be A(e)
        return QuaternionOrder(A, [A(list(e)) for e in B.intersection(C).basis()])

    def free_module(self):
        """
        Return the free `\\ZZ`-module that corresponds to this order
        inside the vector space corresponding to the ambient
        quaternion algebra.

        OUTPUT: a free `\\ZZ`-module of rank 4

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1).maximal_order()
            sage: R.basis()
            (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
            sage: R.free_module()
            Free module of degree 4 and rank 4 over Integer Ring
            Echelon basis matrix:
            [1/2   0 1/2   0]
            [  0 1/2   0 1/2]
            [  0   0   1   0]
            [  0   0   0   1]
        """
        try: return self.__free_module
        except AttributeError: pass
        V = self.quaternion_algebra().base_ring()**4
        M = V.span([V(list(g)) for g in self.basis()], ZZ)
        self.__free_module = M
        return M

    def discriminant(self):
        r"""
        Return the discriminant of this order, which we define as
        `\sqrt{ det ( Tr(e_i \bar{e_j} ) ) }`, where `\{e_i\}` is the
        basis of the order.

        OUTPUT: rational number

        EXAMPLES::

            sage: QuaternionAlgebra(-11,-1).maximal_order().discriminant()
            11
            sage: S = BrandtModule(11,5).order_of_level_N()
            sage: S.discriminant()
            55
            sage: type(S.discriminant())
            <type 'sage.rings.rational.Rational'>
        """
        L = []
        for d in self.basis():
            MM = []
            for e in self.basis():
                MM.append( (d * e.conjugate()).reduced_trace() )
            L.append(MM)

        return (MatrixSpace(QQ, 4, 4)(L)).determinant().sqrt()

    def left_ideal(self, gens, check=True):
        r"""
        Return the ideal with given gens over `\ZZ`.

        INPUT:

        - ``gens`` -- a list of elements of this quaternion order

        - ``check`` -- bool (default: ``True``); if ``False``, then ``gens`` must
          4-tuple that forms a Hermite basis for an ideal

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1).maximal_order()
            sage: R.left_ideal([2*a for a in R.basis()])
            Fractional ideal (1 + j, i + k, 2*j, 2*k)
        """
        if self.base_ring() == ZZ:
            return QuaternionFractionalIdeal_rational(gens, left_order=self, check=check)
        else:
            raise NotImplementedError, "ideal only implemented for quaternion algebras over QQ"

    def right_ideal(self, gens, check=True):
        r"""
        Return the ideal with given gens over `\ZZ`.

        INPUT:

        - ``gens`` -- a list of elements of this quaternion order

        - ``check`` -- bool (default: ``True``); if ``False``, then ``gens`` must
          4-tuple that forms a Hermite basis for an ideal

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1).maximal_order()
            sage: R.right_ideal([2*a for a in R.basis()])
            Fractional ideal (1 + j, i + k, 2*j, 2*k)
        """
        if self.base_ring() == ZZ:
            return QuaternionFractionalIdeal_rational(gens, right_order=self, check=check)
        else:
            raise NotImplementedError, "ideal only implemented for quaternion algebras over QQ"

    def unit_ideal(self):
        """
        Return the unit ideal in this quaternion order.

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1).maximal_order()
            sage: I = R.unit_ideal(); I
            Fractional ideal (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
        """
        if self.base_ring() == ZZ:
            return QuaternionFractionalIdeal_rational(self.basis(), left_order=self, right_order=self, check=False)
        else:
            raise NotImplementedError, "ideal only implemented for quaternion algebras over QQ"

    def quadratic_form(self):
        """
        Return the normalized quadratic form associated to this quaternion order.

        OUTPUT: quadratic form

        EXAMPLES::

            sage: R = BrandtModule(11,13).order_of_level_N()
            sage: Q = R.quadratic_form(); Q
            Quadratic form in 4 variables over Rational Field with coefficients:
            [ 14 253 55 286 ]
            [ * 1455 506 3289 ]
            [ * * 55 572 ]
            [ * * * 1859 ]
            sage: Q.theta_series(10)
            1 + 2*q + 2*q^4 + 4*q^6 + 4*q^8 + 2*q^9 + O(q^10)
        """
        return self.unit_ideal().quadratic_form()

    def ternary_quadratic_form(self):
        """
        Return the ternary quadratic form associated to this order.

        OUTPUT:

        - QuadraticForm

        This function computes the positive definition quadratic form
        obtained by letting G be the trace zero subspace of ZZ +
        2*self, which has rank 3, and restricting the pairing
        (x,y) = (x.conjugate()*y).reduced_trace()
        to G.

        APPLICATIONS: Ternary quadratic forms associated to an order
        in a rational quaternion algebra are useful in computing with
        Gross points, in decided whether quaternion orders have
        embeddings from orders in quadratic imaginary fields, and in
        computing elements of the Kohnen plus subspace of modular
        forms of weight 3/2.

        EXAMPLES::

            sage: R = BrandtModule(11,13).order_of_level_N()
            sage: Q = R.ternary_quadratic_form(); Q
            Quadratic form in 3 variables over Rational Field with coefficients:
            [ 5820 1012 13156 ]
            [ * 55 1144 ]
            [ * * 7436 ]
            sage: factor(Q.disc())
            2^4 * 11^2 * 13^2

        The following theta series is a modular form of weight 3/2 and level 4*11*13::

            sage: Q.theta_series(100)
            1 + 2*q^23 + 2*q^55 + 2*q^56 + 2*q^75 + 4*q^92 + O(q^100)
        """
        if self.base_ring() != ZZ:
            raise NotImplementedError, "ternary quadratic form of order only implemented for quaternion algebras over QQ"

        Q = self.quaternion_algebra()
        # 2*R + ZZ
        twoR = self.free_module().scale(2)
        A = twoR.ambient_module()
        Z = twoR.span( [Q(1).coefficient_tuple()], ZZ)
        S = twoR + Z
        # Now we intersect with the trace 0 submodule
        v = [b.reduced_trace() for b in Q.basis()]
        M = matrix(QQ,4,1,v)
        tr0 = M.kernel()
        G = tr0.intersection(S)
        B = [Q(a) for a in G.basis()]
        m = matrix(QQ,[[x.pair(y) for x in B] for y in B])
        from sage.quadratic_forms.quadratic_form import QuadraticForm
        return QuadraticForm(m)


class QuaternionFractionalIdeal(Ideal_fractional):
    pass

class QuaternionFractionalIdeal_rational(QuaternionFractionalIdeal):
    """
    A fractional ideal in a rational quaternion algebra.
    """
    def __init__(self, basis, left_order=None, right_order=None, check=True):
        """
        INPUT:

        - ``left_order`` -- a quaternion order or ``None``

        - ``right_order`` -- a quaternion order or ``None``

        - ``basis`` -- tuple of length 4 of elements in of ambient
          quaternion algebra whose `\\ZZ`-span is an ideal

        - ``check`` -- bool (default: ``True``); if ``False``, do no type
          checking, and the input basis *must* be in Hermite form.

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1).maximal_order()
            sage: R.right_ideal(R.basis())
            Fractional ideal (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
            sage: R.right_ideal(tuple(R.basis()), check=False)
            Fractional ideal (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
        """
        if check:
            if left_order is not None and not isinstance(left_order, QuaternionOrder):
                raise TypeError, "left_order must be a quaternion order or None"
            if right_order is not None and not isinstance(right_order, QuaternionOrder):
                raise TypeError, "right_order must be a quaternion order or None"
            if not isinstance(basis, (list, tuple)):
                raise TypeError, "basis must be a list or tuple"

        self.__left_order = left_order
        self.__right_order = right_order

        if check:
            try:
                Q = self.quaternion_order().quaternion_algebra()
            except RuntimeError:
                Q = basis[0].parent()
            basis = tuple([Q(v) for v in
                           (QQ**4).span([Q(v).coefficient_tuple() for v in basis], ZZ).basis()])
        self.__basis = basis

    def quaternion_algebra(self):
        """
        Return the ambient quaternion algebra that contains this fractional ideal.

        OUTPUT: a quaternion algebra

        EXAMPLES::

            sage: I = BrandtModule(3,5).right_ideals()[1]; I
            Fractional ideal (2 + 6*j + 4*k, 2*i + 4*j + 34*k, 8*j + 32*k, 40*k)
            sage: I.quaternion_algebra()
            Quaternion Algebra (-1, -3) with base ring Rational Field
        """
        try: return self.__quaternion_algebra
        except AttributeError: pass
        A = self.__basis[0].parent()
        self.__quaternion_algebra = A
        return A

    def _compute_order(self, side='left'):
        r"""
        Used internally to compute either the left or right order
        associated to an ideal in a quaternion algebra.  If
        action='right', compute the left order, and if action='left'
        compute the right order.

        INPUT:

            - ``side`` -- 'left' or 'right'

        EXAMPLES::

            sage: R.<i,j,k> = QuaternionAlgebra(-1,-11)
            sage: I = R.ideal([2 + 2*j + 140*k, 2*i + 4*j + 150*k, 8*j + 104*k, 152*k])
            sage: Ol = I._compute_order('left'); Ol
            Order of Quaternion Algebra (-1, -11) with base ring Rational Field with basis (1/2 + 1/2*j + 35*k, 1/4*i + 1/2*j + 75/4*k, j + 32*k, 38*k)
            sage: Or = I._compute_order('right'); Or
            Order of Quaternion Algebra (-1, -11) with base ring Rational Field with basis (1/2 + 1/2*j + 16*k, 1/2*i + 11/2*k, j + 13*k, 19*k)
            sage: Ol.discriminant()
            209
            sage: Or.discriminant()
            209
            sage: I.left_order() == Ol
            True
            sage: I.right_order() == Or
            True

        ALGORITHM: Let `b_1, b_2, b_3, b_3` be a basis for this
        fractional ideal `I`, and assume we want to compute the left
        order of `I` in the quaternion algebra `Q`.  Then
        multiplication by `b_i` on the right defines a map `B_i:Q \to
        Q`.  We have
           `R = B_1^{-1}(I) \cap B_2^{-1}(I) \cap B_3^{-1}(I)\cap B_4^{-1}(I).`
        This is because
           `B_n^{-1}(I) = \{\alpha \in Q : \alpha b_n \in I \},`
        and
           `R = \{\alpha \in Q : \alpha b_n \in I, n=1,2,3,4\}.`
        """
        if side == 'left': action = 'right'
        elif side == 'right': action = 'left'
        else: ValueError, "side must be 'left' or 'right'"
        Q = self.quaternion_algebra()
        if Q.base_ring() != QQ:
            raise NotImplementedError, "computation of left and right orders only implemented over QQ"
        M = [(~b).matrix(action=action) for b in self.basis()]
        B = self.basis_matrix()
        invs = [B*m for m in M]
        # Now intersect the row spans of each matrix in invs
        ISB = [Q(v) for v in intersection_of_row_modules_over_ZZ(invs).row_module(ZZ).basis()]
        return Q.quaternion_order(ISB)


    def left_order(self):
        """
        Return the left order associated to this fractional ideal.

        OUTPUT: an order in a quaternion algebra

        EXAMPLES::

            sage: B = BrandtModule(11)
            sage: R = B.maximal_order()
            sage: I = R.unit_ideal()
            sage: I.left_order()
            Order of Quaternion Algebra (-1, -11) with base ring Rational Field with basis (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)

        We do a consistency check::

            sage: B = BrandtModule(11,19); R = B.right_ideals()
            sage: print [r.left_order().discriminant() for r in R]
            [209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209]
        """
        if self.__left_order is None:
            self.__left_order = self._compute_order(side='left')
        return self.__left_order

    def right_order(self):
        """
        Return the right order associated to this fractional ideal.

        OUTPUT: an order in a quaternion algebra

        EXAMPLES::

            sage: I = BrandtModule(389).right_ideals()[1]; I
            Fractional ideal (2 + 6*j + 2*k, i + 2*j + k, 8*j, 8*k)
            sage: I.right_order()
            Order of Quaternion Algebra (-2, -389) with base ring Rational Field with basis (1/2 + 1/2*j + 1/2*k, 1/4*i + 1/2*j + 1/4*k, j, k)
            sage: I.left_order()
            Order of Quaternion Algebra (-2, -389) with base ring Rational Field with basis (1/2 + 1/2*j + 3/2*k, 1/8*i + 1/4*j + 9/8*k, j + k, 2*k)

        The following is a big consistency check.  We take reps for
        all the right ideal classes of a certain order, take the
        corresponding left orders, then take ideals in the left orders
        and from those compute the right order again::

            sage: B = BrandtModule(11,19); R = B.right_ideals()
            sage: O = [r.left_order() for r in R]
            sage: J = [O[i].left_ideal(R[i].basis()) for i in range(len(R))]
            sage: len(set(J))
            18
            sage: len(set([I.right_order() for I in J]))
            1
            sage: J[0].right_order() == B.order_of_level_N()
            True
        """
        if self.__right_order is None:
            self.__right_order = self._compute_order(side='right')
        return self.__right_order

    def __repr__(self):
        """
        Return string representation of this quaternion fractional ideal.

        EXAMPLES::

            sage: I = BrandtModule(11).right_ideals()[1]
            sage: type(I)
            <class 'sage.algebras.quatalg.quaternion_algebra.QuaternionFractionalIdeal_rational'>
            sage: I.__repr__()
            'Fractional ideal (2 + 6*j + 4*k, 2*i + 4*j + 2*k, 8*j, 8*k)'
        """
        return 'Fractional ideal %s'%(self.gens(),)

    def quaternion_order(self):
        """
        Return the order for which this ideal is a left or right
        fractional ideal.  If this ideal has both a left and right
        ideal structure, then the left order is returned.  If it has
        neither structure, then an error is raised.

        OUTPUT: QuaternionOrder

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1).maximal_order()
            sage: R.unit_ideal().quaternion_order() is R
            True
        """
        try: return self.__quaternion_order
        except AttributeError: pass
        if self.__left_order is not None:
            A = self.__left_order
        elif self.__right_order is not None:
            A = self.__right_order
        else:
            raise RuntimeError, "unable to determine quaternion order of ideal without known order"
        self.__quaternion_order = A
        return A

    def ring(self):
        """
        Return ring that this is a fractional ideal for.

        EXAMPLES::

            sage: R = QuaternionAlgebra(-11,-1).maximal_order()
            sage: R.unit_ideal().ring() is R
            True
        """
        return self.quaternion_order()

    def basis(self):
        """
        Return basis for this fractional ideal.  The basis is in Hermite form.

        OUTPUT: tuple

        EXAMPLES::

            sage: QuaternionAlgebra(-11,-1).maximal_order().unit_ideal().basis()
            (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
        """
        return self.__basis

    def gens(self):
        """
        Return the generators for this ideal, which are the same as
        the `\\ZZ`-basis for this ideal.

        EXAMPLES::

            sage: QuaternionAlgebra(-11,-1).maximal_order().unit_ideal().gens()
            (1/2 + 1/2*j, 1/2*i + 1/2*k, j, k)
        """
        return self.__basis

    def __cmp__(self, right):
        """
        Compare this fractional quaternion ideal to ``right``.  If
        ``right`` is not a fractional quaternion ideal a TypeError is
        raised.  If the fractional ideals are in different ambient
        quaternion algebras, then the quaternion algebras themselves
        are compared.

        INPUT:

        - ``right`` - another fractional quaternion ideal

        EXAMPLES::

            sage: I = QuaternionAlgebra(-11,-1).maximal_order().unit_ideal()
            sage: I == I                # indirect doctest
            True
            sage: I == 5
            False
        """
        if not isinstance(right, QuaternionFractionalIdeal_rational):
            raise TypeError
        c = cmp(self.quaternion_order(), right.quaternion_order())
        if c: return c
        return cmp(self.__basis, right.__basis)

    def basis_matrix(self):
        """
        Return basis matrix `M` in Hermite normal form for self as a
        matrix with rational entries.

        If `Q` is the ambient quaternion algebra, then the `\\ZZ`-span of
        the rows of `M` viewed as linear combinations of Q.basis() =
        `[1,i,j,k]` is the fractional ideal self.  Also, M *
        M.denominator() is an integer matrix in Hermite normal form.

        OUTPUT: matrix over `\\QQ`

        EXAMPLES::

            sage: QuaternionAlgebra(-11,-1).maximal_order().unit_ideal().basis_matrix()
            [1/2   0 1/2   0]
            [  0 1/2   0 1/2]
            [  0   0   1   0]
            [  0   0   0   1]
        """
        try: return self.__hermite_basis_matrix
        except AttributeError: pass
        B = quaternion_algebra_cython.rational_matrix_from_rational_quaternions(self.__basis)
        self.__hermite_basis_matrix = B
        return B

    def free_module(self):
        """
        Return the free module associated to this quaternionic
        fractional ideal, viewed as a submodule of
        ``Q.free_module()``, where ``Q`` is the ambient quaternion
        algebra.

        OUTPUT: free `\\ZZ`-module of rank 4 embedded in an ambient `\\QQ^4`.

        EXAMPLES::

            sage: QuaternionAlgebra(-11,-1).maximal_order().unit_ideal().basis_matrix()
            [1/2   0 1/2   0]
            [  0 1/2   0 1/2]
            [  0   0   1   0]
            [  0   0   0   1]
        """
        try: return self.__free_module
        except AttributeError:
            M = self.hermite_basis_matrix().row_module(ZZ)
            self.__free_module = M
            return M

    def theta_series_vector(self, B):
        """
        Return theta series coefficients of self, as a vector of `B` integers.

        INPUT:

        - ``B`` -- positive integer

        OUTPUT: vector over `\\ZZ` with ``B`` entries

        EXAMPLES::

            sage: I = BrandtModule(37).right_ideals()[1]; I
            Fractional ideal (2 + 6*j + 2*k, i + 2*j + k, 8*j, 8*k)
            sage: I.theta_series_vector(5)
            (1, 0, 2, 2, 6)
            sage: I.theta_series_vector(10)
            (1, 0, 2, 2, 6, 4, 8, 6, 10, 10)
            sage: I.theta_series_vector(5)
            (1, 0, 2, 2, 6)
        """
        B = Integer(B)
        try:
            if len(self.__theta_series_vector)>= B: return self.__theta_series_vector[:B]
        except AttributeError: pass
        V = FreeModule(ZZ, B)
        Q = self.quadratic_form()
        v = V(Q.representation_number_list(B))
        self.__theta_series_vector = v
        return v

    def quadratic_form(self):
        """
        Return the normalized quadratic form associated to this quaternion ideal.

        OUTPUT: quadratic form

        EXAMPLES::

            sage: I = BrandtModule(11).right_ideals()[1]
            sage: Q = I.quadratic_form(); Q
            Quadratic form in 4 variables over Rational Field with coefficients:
            [ 18 22 33 22 ]
            [ * 7 22 11 ]
            [ * * 22 0 ]
            [ * * * 22 ]
            sage: Q.theta_series(10)
            1 + 12*q^2 + 12*q^3 + 12*q^4 + 12*q^5 + 24*q^6 + 24*q^7 + 36*q^8 + 36*q^9 + O(q^10)
            sage: I.theta_series(10)
            1 + 12*q^2 + 12*q^3 + 12*q^4 + 12*q^5 + 24*q^6 + 24*q^7 + 36*q^8 + 36*q^9 + O(q^10)
        """
        try: return self.__quadratic_form
        except AttributeError: pass
        from sage.quadratic_forms.quadratic_form import QuadraticForm
        # first get the gram matrix
        gram_matrix = self.gram_matrix()
        # rescale so that there are no denominators
        gram_matrix, _ = gram_matrix._clear_denom()
        # Make sure gcd of all entries is 1.
        g = gram_matrix.gcd()
        if g != 1:
            gram_matrix = gram_matrix / g
        # now get the quadratic form
        Q = QuadraticForm(gram_matrix)
        self.__quadratic_form = Q
        return Q

    def theta_series(self, B, var='q'):
        """
        Return normalized theta series of self, as a power series over
        `\\ZZ` in the variable ``var``, which is 'q' by default.

        The normalized theta series is by definition

        .. math::

            \\theta_I(q)=\\sum_{x \\in I} q^{\\frac{N(x)}{N(I)}}

        INPUT:

        - ``B`` -- positive integer
        - ``var`` -- string (default: 'q')

        OUTPUT: power series

        EXAMPLES::

            sage: I = BrandtModule(11).right_ideals()[1]; I
            Fractional ideal (2 + 6*j + 4*k, 2*i + 4*j + 2*k, 8*j, 8*k)
            sage: I.norm()
            64
            sage: I.theta_series(5)
            1 + 12*q^2 + 12*q^3 + 12*q^4 + O(q^5)
            sage: I.theta_series(5,'T')
            1 + 12*T^2 + 12*T^3 + 12*T^4 + O(T^5)
            sage: I.theta_series(3)
            1 + 12*q^2 + O(q^3)
        """
        try:
            if self.__theta_series.prec() >= B:
                if var == self.__theta_series.variable():
                    return self.__theta_series.add_bigoh(B)
                else:
                    ZZ[[var]](self.__theta_series.list()[:B+1])
        except AttributeError: pass
        v = self.theta_series_vector(B)
        theta = ZZ[[var]](v.list()).add_bigoh(B)
        self.__theta_series = theta
        return theta

    def gram_matrix(self):
        """
        Return the Gram matrix of this fractional ideal.

        OUTPUT: 4x4 matrix over `\\QQ`.

        EXAMPLES::

            sage: I = BrandtModule(3,5).right_ideals()[1]; I
            Fractional ideal (2 + 6*j + 4*k, 2*i + 4*j + 34*k, 8*j + 32*k, 40*k)
            sage: I.gram_matrix()
            [  640  1920  2112  1920]
            [ 1920 14080 13440 16320]
            [ 2112 13440 13056 15360]
            [ 1920 16320 15360 19200]
        """
        try: return self.__gram_matrix
        except AttributeError: pass
        M = []
        A = self.__basis
        B = [z.conjugate() for z in self.__basis]
        two = QQ(2)
        m = [two*(a*b).reduced_trace() for b in B for a in A]
        G = M44(m,coerce=False)
        self.__gram_matrix = G
        return G

    def norm(self):
        """
        Return the norm of this fractional ideal.

        OUTPUT: rational number

        EXAMPLES::

            sage: C = BrandtModule(37).right_ideals()
            sage: [I.norm() for I in C]
            [32, 64, 64]
        """
        G = self.gram_matrix()
        r = G.det().abs()
        assert r.is_square(), "first is bad!"
        r = r.sqrt()
        r/= self.quaternion_order().discriminant()
        assert r.is_square(), "second is bad!"
        return r.sqrt()

    def conjugate(self):
        """
        Return the ideal with generators the conjugates of the generators for self.

        OUTPUT: a quaternionic fractional ideal

        EXAMPLES::

            sage: I = BrandtModule(3,5).right_ideals()[1]; I
            Fractional ideal (2 + 6*j + 4*k, 2*i + 4*j + 34*k, 8*j + 32*k, 40*k)
            sage: I.conjugate()
            Fractional ideal (2 + 2*j + 28*k, 2*i + 4*j + 34*k, 8*j + 32*k, 40*k)
        """
        return self.quaternion_algebra().ideal([b.conjugate() for b in self.basis()],
                                               left_order=self.__right_order,
                                               right_order=self.__left_order)

    def __mul__(self, right):
        """
        Return the product of the fractional ideals ``self`` and ``right``.

        NOTE: We do not keep track of left or right order structure.

        EXAMPLES::

            sage: I = BrandtModule(3,5).right_ideals()[1]; I
            Fractional ideal (2 + 6*j + 4*k, 2*i + 4*j + 34*k, 8*j + 32*k, 40*k)
            sage: I*I
            Fractional ideal (8 + 24*j + 16*k, 8*i + 16*j + 136*k, 32*j + 128*k, 160*k)
            sage: I*I.conjugate()
            Fractional ideal (16 + 16*j + 224*k, 8*i + 16*j + 136*k, 32*j + 128*k, 320*k)
            sage: I.multiply_by_conjugate(I)
            Fractional ideal (16 + 16*j + 224*k, 8*i + 16*j + 136*k, 32*j + 128*k, 320*k)
        """
        if not isinstance(right, QuaternionFractionalIdeal_rational):
            raise TypeError, "right must be a quaternion ideal"
        gens = [a*b for a in self.basis() for b in right.basis()]
        #if self.__right_order == right.__left_order:
        #    left_order = self.__left_order
        #    right_order = right.__right_order
        basis = tuple(basis_for_quaternion_lattice(gens))
        A = self.quaternion_algebra()
        return A.ideal(basis, check=False)

    def multiply_by_conjugate(self, J):
        """
        Return product of self and the conjugate Jbar of `J`.

        INPUT:

        - ``J`` -- a quaternion ideal.

        OUTPUT: a quaternionic fractional ideal.

        EXAMPLES::

            sage: R = BrandtModule(3,5).right_ideals()
            sage: R[0].multiply_by_conjugate(R[1])
            Fractional ideal (8 + 8*j + 112*k, 8*i + 16*j + 136*k, 32*j + 128*k, 160*k)
            sage: R[0]*R[1].conjugate()
            Fractional ideal (8 + 8*j + 112*k, 8*i + 16*j + 136*k, 32*j + 128*k, 160*k)
        """
        Jbar = [b.conjugate() for b in J.basis()]
        gens = [a*b for a in self.basis() for b in Jbar]
        basis = tuple(basis_for_quaternion_lattice(gens))
        R = self.quaternion_algebra()
        return R.ideal(basis, check=False)

    def is_equivalent(I, J, B=10):
        """
        Return ``True`` if ``I`` and ``J`` are equivalent as right ideals.

        INPUT:

        - ``I`` -- a fractional quaternion ideal (self)

        - ``J`` -- a fractional quaternion ideal with same order as ``I``

        - ``B`` -- a bound to compute and compare theta series before
          doing the full equivalence test

        OUTPUT: bool

        EXAMPLES::

            sage: R = BrandtModule(3,5).right_ideals(); len(R)
            2
            sage: R[0].is_equivalent(R[1])
            False
            sage: R[0].is_equivalent(R[0])
            True
            sage: OO = R[0].quaternion_order()
            sage: S = OO.right_ideal([3*a for a in R[0].basis()])
            sage: R[0].is_equivalent(S)
            True
        """
        if not isinstance(I, QuaternionFractionalIdeal_rational):
            return False

        if I.right_order() != J.right_order():
            raise ValueError, "I and J must be right ideals"

        # Just test theta series first.  If the theta series are
        # different, the ideals are definitely not equivalent.
        if B > 0 and I.theta_series_vector(B) != J.theta_series_vector(B):
            return False

        # The theta series are the same, so perhaps the ideals are
        # equivalent.  We use Prop 1.18 of [Pizer, 1980] to decide.
        # 1. Compute I * Jbar
        # see Prop. 1.17 in Pizer.  Note that we use IJbar instead of
        # JbarI since we work with right ideals
        IJbar = I.multiply_by_conjugate(J)

        # 2. Determine if there is alpha in K such
        #    that N(alpha) = N(I)*N(J) as explained by Pizer.
        c = IJbar.theta_series_vector(2)[1]
        return c != 0

    def __contains__(self, x):
        """
        Returns whether x is in self.

        EXAMPLES::
            sage: R.<i,j,k> = QuaternionAlgebra(-3, -13)
            sage: I = R.ideal([2+i, 3*i, 5*j, j+k])
            sage: 2+i in I
            True
            sage: 2+i+j+k in I
            True
            sage: 1+i in I
            False
            sage: 101*j + k in I
            True
        """
        try:
            x = self.quaternion_algebra()(x)
            return self.basis_matrix().transpose().solve_right(vector(x)) in ZZ**4
        except (ValueError, TypeError):
            return False

#######################################################################
# Some utility functions that are needed here and are too
# specialized to go elsewhere.
#######################################################################

M44 = MatrixSpace(QQ, 4)

def basis_for_quaternion_lattice(gens):
    """
    Return a basis for the `\\ZZ`-lattice in a quaternion algebra
    spanned by the given gens.

    INPUT:

    - ``gens`` -- list of elements of a single quaternion algebra

    EXAMPLES::

        sage: A.<i,j,k> = QuaternionAlgebra(-1,-7)
        sage: sage.algebras.quatalg.quaternion_algebra.basis_for_quaternion_lattice([i+j, i-j, 2*k, A(1/3)])
        [1/3, i + j, 2*j, 2*k]
    """
    if len(gens) == 0: return []
    Z, d = quaternion_algebra_cython.integral_matrix_and_denom_from_rational_quaternions(gens)
    H = Z._hnf_pari(0, include_zero_rows=False)
    A = gens[0].parent()
    return quaternion_algebra_cython.rational_quaternions_from_integral_matrix_and_denom(A, H, d)


def intersection_of_row_modules_over_ZZ(v):
    """
    Intersects the ZZ-modules with basis matrices the full rank 4x4
    QQ-matrices in the list v.  The returned intersection is
    represented by a 4x4 matrix over QQ.  This can also be done using
    modules and intersection, but that would take over twice as long
    because of overhead, hence this function.

    EXAMPLES::

        sage: a = matrix(QQ,4,[-2, 0, 0, 0, 0, -1, -1, 1, 2, -1/2, 0, 0, 1, 1, -1, 0])
        sage: b = matrix(QQ,4,[0, -1/2, 0, -1/2, 2, 1/2, -1, -1/2, 1, 2, 1, -2, 0, -1/2, -2, 0])
        sage: c = matrix(QQ,4,[0, 1, 0, -1/2, 0, 0, 2, 2, 0, -1/2, 1/2, -1, 1, -1, -1/2, 0])
        sage: v = [a,b,c]
        sage: from sage.algebras.quatalg.quaternion_algebra import intersection_of_row_modules_over_ZZ
        sage: M = intersection_of_row_modules_over_ZZ(v); M
        [   2    0   -1   -1]
        [   4   -1   -1    3]
        [  -3 19/2   -1   -4]
        [   2   -3   -8    4]
        sage: M2 = a.row_module(ZZ).intersection(b.row_module(ZZ)).intersection(c.row_module(ZZ))
        sage: M.row_module(ZZ) == M2
        True
    """
    if len(v) <= 0:
        raise ValueError, "v must have positive length"
    if len(v) == 1:
        return v[0]
    elif len(v) == 2:
        # real work - the base case
        a, b = v
        s,_ = a.stack(b)._clear_denom()
        s = s.transpose()
        K = s._right_kernel_matrix(algorithm='pari')
        n = a.nrows()
        return K.matrix_from_columns(range(n)) * a
    else:
        # induct
        w = intersection_of_row_modules_over_ZZ(v[:2])
        return intersection_of_row_modules_over_ZZ([w] + v[2:])
