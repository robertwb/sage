#include "solverconf_helper.h"

size_t setup_map(sc_entry *entries, CMSat::SolverConf &solver_conf, const size_t n) {
  assert(n >= 53);
  entries[ 0] = {  t_double, "random_var_freq", (void*)&(solver_conf.random_var_freq), "The frequency with which the decision heuristic tries to choose a random variable.        (default 0.02)"};
  entries[ 1] = {  t_double, "clause_decay", (void*)&(solver_conf.clause_decay), "Inverse of the clause activity decay factor. Only applies if using MiniSat-style clause activities  (default: 1 / 0.999)"};
  entries[ 2] = {     t_int, "restart_first", (void*)&(solver_conf.restart_first), "The initial restart limit.                                                                (default 100)"};
  entries[ 3] = {  t_double, "restart_inc", (void*)&(solver_conf.restart_inc), "The factor with which the restart limit is multiplied in each restart.                    (default 1.5)"};
  entries[ 4] = {  t_double, "learntsize_factor", (void*)&(solver_conf.learntsize_factor), "The intitial limit for learnt clauses is a factor of the original clauses.                (default 1 / 3)"};
  entries[ 5] = {  t_double, "learntsize_inc", (void*)&(solver_conf.learntsize_inc), "The limit for learnt clauses is multiplied with this factor each restart.                 (default 1.1)"};
  entries[ 6] = {    t_bool, "expensive_ccmin", (void*)&(solver_conf.expensive_ccmin), "Should clause minimisation by Sorensson&Biere be used?                                    (default TRUE)"};
  entries[ 7] = {     t_int, "polarity_mode", (void*)&(solver_conf.polarity_mode), "Controls which polarity the decision heuristic chooses. Auto means Jeroslow-Wang          (default: polarity_auto)"};
  entries[ 8] = {     t_int, "verbosity", (void*)&(solver_conf.verbosity), "Verbosity level. 0=silent, 1=some progress report, 2=lots of report, 3 = all report       (default 2)"};
  entries[ 9] = {     t_Var, "restrictPickBranch", (void*)&(solver_conf.restrictPickBranch), "Pick variables to branch on preferentally from the highest [0, restrictedPickBranch]. If set to 0, preferentiality is turned off (i.e. picked randomly between [0, all])"};
  entries[10] = {t_uint32_t, "simpBurstSConf", (void*)&(solver_conf.simpBurstSConf), ""};
  entries[11] = {  t_double, "simpStartMult", (void*)&(solver_conf.simpStartMult), ""};
  entries[12] = {  t_double, "simpStartMMult", (void*)&(solver_conf.simpStartMMult), ""};
  entries[13] = {    t_bool, "doPerformPreSimp", (void*)&(solver_conf.doPerformPreSimp), ""};
  entries[14] = {  t_double, "failedLitMultiplier", (void*)&(solver_conf.failedLitMultiplier), ""};
  entries[15] = {    t_bool, "doFindXors", (void*)&(solver_conf.doFindXors), "Automatically find non-binary xor clauses and convert them to xor clauses"};
  entries[16] = {    t_bool, "doFindEqLits", (void*)&(solver_conf.doFindEqLits), "Automatically find binary xor clauses (i.e. variable equi- and antivalences)"};
  entries[17] = {    t_bool, "doRegFindEqLits", (void*)&(solver_conf.doRegFindEqLits), "Regularly find binary xor clauses (i.e. variable equi- and antivalences)"};
  entries[18] = {    t_bool, "doReplace", (void*)&(solver_conf.doReplace), "Should var-replacing be performed? If set to FALSE, equi- and antivalent variables will not be replaced with one another."};
  entries[19] = {    t_bool, "doConglXors", (void*)&(solver_conf.doConglXors), "Do variable elimination at the XOR-level (xor-ing 2 xor clauses thereby removing a variable)"};
  entries[20] = {    t_bool, "doHeuleProcess", (void*)&(solver_conf.doHeuleProcess), "Perform local subsitutuion as per Heule's theis"};
  entries[21] = {    t_bool, "doSchedSimp", (void*)&(solver_conf.doSchedSimp), "Should simplifyProblem() be scheduled regularly? (if set to FALSE, a lot of opmitisations are disabled)"};
  entries[22] = {    t_bool, "doSatELite", (void*)&(solver_conf.doSatELite), "Should try to subsume & self-subsuming resolve & variable-eliminate & block-clause eliminate?"};
  entries[23] = {    t_bool, "doXorSubsumption", (void*)&(solver_conf.doXorSubsumption), "Should try to subsume & local-subsitute xor clauses"};
  entries[24] = {    t_bool, "doHyperBinRes", (void*)&(solver_conf.doHyperBinRes), "Should try carry out hyper-binary resolution"};
  entries[25] = {    t_bool, "doBlockedClause", (void*)&(solver_conf.doBlockedClause), "Should try to remove blocked clauses"};
  entries[26] = {    t_bool, "doVarElim", (void*)&(solver_conf.doVarElim), "Perform variable elimination"};
  entries[27] = {    t_bool, "doSubsume1", (void*)&(solver_conf.doSubsume1), "Perform self-subsuming resolution"};
  entries[28] = {    t_bool, "doClausVivif", (void*)&(solver_conf.doClausVivif), "Perform asymmetric branching at the beginning of the solving"};
  entries[29] = {    t_bool, "doSortWatched", (void*)&(solver_conf.doSortWatched), "Sort watchlists according to size&type: binary, tertiary, normal (>3-long), xor clauses"};
  entries[30] = {    t_bool, "doMinimLearntMore", (void*)&(solver_conf.doMinimLearntMore), "Perform learnt-clause minimisation using watchists' binary and tertiary clauses? ('strong minimization' in PrecoSat)"};
  entries[31] = {    t_bool, "doMinimLMoreRecur", (void*)&(solver_conf.doMinimLMoreRecur), "Always perform recursive/transitive on-the-fly self self-subsuming resolution --> an enhancement of 'strong minimization' of PrecoSat"};
  entries[32] = {    t_bool, "doFailedLit", (void*)&(solver_conf.doFailedLit), "Carry out Failed literal probing + doubly propagated literal detection + 2-long xor clause detection during failed literal probing + hyper-binary resoolution"};
  entries[33] = {    t_bool, "doRemUselessBins", (void*)&(solver_conf.doRemUselessBins), "Should try to remove useless binary clauses at the beginning of solving?"};
  entries[34] = {    t_bool, "doSubsWBins", (void*)&(solver_conf.doSubsWBins), ""};
  entries[35] = {    t_bool, "doSubsWNonExistBins", (void*)&(solver_conf.doSubsWNonExistBins), "Try to do subsumption and self-subsuming resolution with non-existent binary clauses (i.e. binary clauses that don't exist but COULD exists)"};
  entries[36] = {    t_bool, "doRemUselessLBins", (void*)&(solver_conf.doRemUselessLBins), "Try to remove useless learnt binary clauses"};
  entries[37] = {    t_bool, "doPrintAvgBranch", (void*)&(solver_conf.doPrintAvgBranch), ""};
  entries[38] = {    t_bool, "doCacheOTFSSR", (void*)&(solver_conf.doCacheOTFSSR), ""};
  entries[39] = {    t_bool, "doCacheOTFSSRSet", (void*)&(solver_conf.doCacheOTFSSRSet), ""};
  entries[40] = {    t_bool, "doExtendedSCC", (void*)&(solver_conf.doExtendedSCC), ""};
  entries[41] = {    t_bool, "doCalcReach", (void*)&(solver_conf.doCalcReach), "Calculate reachability, and influence variable decisions with that"};
  entries[42] = {    t_bool, "doBXor", (void*)&(solver_conf.doBXor), ""};
  entries[43] = {    t_bool, "doOTFSubsume", (void*)&(solver_conf.doOTFSubsume), " ///On-the-fly subsumption"};
  entries[44] = {t_uint64_t, "maxConfl", (void*)&(solver_conf.maxConfl), ""};
  entries[45] = {    t_bool, "isPlain", (void*)&(solver_conf.isPlain), "We are in 'plain' mode: glues can never be 1"};
  entries[46] = {t_uint32_t, "maxRestarts", (void*)&(solver_conf.maxRestarts), ""};
  entries[47] = {    t_bool, "needToDumpLearnts", (void*)&(solver_conf.needToDumpLearnts), "If set to TRUE, learnt clauses will be dumped to the file speified by 'learntsFilename'"};
  entries[48] = {    t_bool, "needToDumpOrig", (void*)&(solver_conf.needToDumpOrig), "If set to TRUE, a simplified version of the original clause-set will be dumped to the file speified by 'origFilename'. The solution to this file should perfectly satisfy the problem"};
  entries[49] = {t_uint32_t, "maxDumpLearntsSize", (void*)&(solver_conf.maxDumpLearntsSize), "When dumping the learnt clauses, this is the maximum clause size that should be dumped"};
  entries[50] = {    t_bool, "libraryUsage", (void*)&(solver_conf.libraryUsage), "Set to true if not used as a library. In fact, this is TRUE by default, and Main.cpp sets it to 'FALSE'. Disables some simplifications at the beginning of solving (mostly performStepsBeforeSolve() )"};
  entries[51] = {    t_bool, "greedyUnbound", (void*)&(solver_conf.greedyUnbound), "If set, then variables will be greedily unbounded (set to l_Undef). This is EXPERIMENTAL"};
  entries[52] = {t_uint32_t, "origSeed", (void*)&(solver_conf.origSeed), ""};
  return 53;
}
