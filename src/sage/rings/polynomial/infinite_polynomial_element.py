"""
Elements of Infinite Polynomial Rings

AUTHORS:

- Simon King <simon.king@uni-jena.de>
- Mike Hansen <mhansen@gmail.com>

An Infinite Polynomial Ring has generators `x_\\ast, y_\\ast,...`, so that the variables are
of the form `x_0, x_1, x_2, ..., y_0, y_1, y_2,...,...` (see :mod:`~sage.rings.polynomial.infinite_polynomial_ring`).
Using the generators, we can create elements as follows::

    sage: X.<x,y> = InfinitePolynomialRing(QQ)
    sage: a = x[3]
    sage: b = y[4]
    sage: a
    x3
    sage: b
    y4
    sage: c = a*b+a^3-2*b^4
    sage: c
    -2*y4^4 + y4*x3 + x3^3

Any Infinite Polynomial Ring ``X`` is equipped with a monomial ordering.
We only consider monomial orderings in which:

    ``X.gen(i)[m] < X.gen(j)[n]`` `\iff` ``i<j``, or ``i==j`` and ``m<n``

Under this restriction, the monomial ordering can be lexicographic (default), degree
lexicographic, or degree reverse lexicographic. Here, the ordering is lexicographic,
and elements can be compared as usual::

    sage: X._order
    'lex'
    sage: a < b
    True

Note that, when a method is called that is not directly implemented for 'InfinitePolynomial',
it is tried to call this method for the underlying *classical* polynomial. This holds, e.g., when
applying the ``latex`` function::

    sage: latex(c)
    -2 y_{4}^{4} + y_{4} x_{3} + x_{3}^{3}

There is a permutation action on Infinite Polynomial Rings by permuting the indices of the
variables::

    sage: P = Permutation(((4,5),(2,3)))
    sage: c^P
    -2*y5^4 + y5*x2 + x2^3

Note that ``P(0)==0``, and thus variables of index zero are invariant
under the permutation action.
More generally, if ``P`` is any callable object that accepts non-negative
integers as input and returns non-negative integers, then ``c^P``
means to apply ``P`` to the variable indices occurring in ``c``.

"""

#*****************************************************************************
#       Copyright (C) 2009 Simon King <king@mathematik.uni-jena.de>
#                          and Mike Hansen <mhansen@gmail.com>,
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.rings.integer_ring import ZZ
from sage.rings.integer import Integer
from sage.structure.element import RingElement
from sage.rings.ring import CommutativeRing
from sage.structure.all import Parent, SageObject
from sage.structure.factory import UniqueFactory
from sage.misc.cachefunc import cached_method
import copy, operator, sys

def InfinitePolynomial(A, p, is_good_poly=False):
    """
    Create an element of a Polynomial Ring with a Countably Infinite Number of Variables

    Usually, an InfinitePolynomial is obtained by using the generators of an
    Infinite Polynomial Ring (see :mod:`~sage.rings.polynomial.infinite_polynomial_ring`).
    But a direct construction is possible as well.

    INPUT:

    - ``A``, an Infinite Polynomial Ring
    - ``p``, which is either an Infinite Polynomial, a *classical* polynomial, a string,
      or anything else that can be interpreted in ``A``.

    If the optional parameter ``is_good_poly`` is given, then it is assumed that ``p`` is
    a *classical* polynomial that can be interpreted in ``A``. Otherwise, the input is checked.

    EXAMPLES::

        sage: from sage.rings.polynomial.infinite_polynomial_element import InfinitePolynomial
        sage: X.<x> = InfinitePolynomialRing(QQ)
        sage: a = InfinitePolynomial(X, '(x1+x2)^2')
        sage: a
        x2^2 + 2*x2*x1 + x1^2
        sage: p = a.polynomial()
        sage: b = InfinitePolynomial(X, p)
        sage: a==b
        True
        sage: InfinitePolynomial(X, int(1))
        1
        sage: InfinitePolynomial(X, 1)
        1
        sage: Y.<x,y> = InfinitePolynomialRing(GF(2), implementation='sparse')
        sage: InfinitePolynomial(Y, a)
        x2^2 + x1^2

    If it is sure that ``p`` is a polynomial that fits well to ``X`` then the optional
    parameter ``is_good_poly`` can be used to speed up the element creation. However,
    this option should be used with care::

        sage: R.<z0> = QQ[]
        sage: InfinitePolynomial(Y, z0, is_good_poly=True)
        z0

    The preceding answer means that it was assumed that ``z0`` fits into an Infinite
    Polynomial Ring generated by ``x`` and ``y`` -- and in the sparse implementation of
    Infinite Polynomial Rings this is not tested. In the default implementation, it is
    somehow indirectly tested: The dense implementation of Infinite Polynomial
    Rings has an underlying ring, and if ``is_good_poly`` is granted, then that underlying
    ring will not be changed, resulting in a traceback.
    ::

        sage: InfinitePolynomial(X, z0, is_good_poly=True)
        Traceback (most recent call last):
        ...
        TypeError: not a constant polynomial
        sage: S.<x4> = QQ[]
        sage: X.polynomial_ring()
        Multivariate Polynomial Ring in x2, x1, x0 over Rational Field
        sage: InfinitePolynomial(X, x4, is_good_poly=True)
        Traceback (most recent call last):
        ...
        TypeError: not a constant polynomial

    Without the optional parameter, the underlying ring is appropriately changed::

        sage: InfinitePolynomial(X, x4)
        x4
        sage: X.polynomial_ring()
        Multivariate Polynomial Ring in x4, x3, x2, x1, x0 over Rational Field

    """
    if hasattr(A,'_P'):
        return InfinitePolynomial_dense(A, p, is_good_poly=is_good_poly)
    return InfinitePolynomial_sparse(A, p, is_good_poly=is_good_poly)

class InfinitePolynomial_sparse(RingElement):
    """
    Element of a sparse Polynomial Ring with a Countably Infinite Number of Variables

    INPUT:

    - ``A``, an Infinite Polynomial Ring in sparse implementation
    - ``p``, which is either an Infinite Polynomial, a *classical* polynomial, a string,
      or anything else that can be interpreted in ``A``.

    If the optional parameter ``is_good_poly`` is given, then it is assumed that ``p`` is
    a *classical* polynomial that can be interpreted in ``A``. Otherwise, the input is checked.


    """
    # Construction and other basic methods
    def __init__(self, A, p, is_good_poly=False):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: a = x[1] + x[2]
            sage: a == loads(dumps(a))
            True

        """
        if is_good_poly:
            self._p = p
            self._has_footprint = False
            self._footprint = {}
            RingElement.__init__(self, A)
            return
        ## Try to find an appropriate ring
        # Case 1: string
        elif isinstance(p,basestring):
            #print 'use string'
            VarList = list(set(A._varpattern.findall(p)))
            VarList.sort(cmp=A.varname_cmp,reverse=True)
            if VarList:
                from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
                R = PolynomialRing(A.base_ring(), VarList, order=A._order)
            else:
                R = A.base_ring()
        # Case 2: python int and those things
        elif (not hasattr(p,'parent')) or (not hasattr(p,'variables')): # catch the case of p=int(1) or p=Integer(1) etc
            #print 'python int'
            R = A._base
        # Case 3: InfinitePolynomial
        elif isinstance(p.parent(), A.__class__):
            #print 'infinite poly'
            if p.parent() is A: # hence, the finite polynomial ring is already good
                R = p._p.parent()
            else:
                VarList = [X for X in p._p.parent().variable_names()]
                VarList.sort(cmp=A.varname_cmp,reverse=True)
                if VarList:
                    from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
                    R = PolynomialRing(A.base_ring(), VarList, order=A._order)
                else:
                    R = A.base_ring()
            p = p._p
        # Case 4: polynomial
        else: # now, p is supposed to be a polynomial. Otherwise, an error will occur
            #print 'classical poly'
            VarList = [X for X in p.parent().variable_names()]
            VarList.sort(cmp=A.varname_cmp,reverse=True)
            if VarList:
                from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
                R = PolynomialRing(A.base_ring(), VarList, order=A._order)
            else:
                R = A.base_ring()

        ## Now, we have a polynomial ring R that fits to A and which contains p
        self._p = R(p)
        self._has_footprint = False
        self._footprint = {}
        RingElement.__init__(self, A)

    def __repr__(self):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: str(x[1] + x[2])  # indirect doctest
            'x2 + x1'

        """
        return repr(self._p)

    def __hash__(self):
        """
        Returns the hash of this element which is just the hash of the
        underlying finite polynomial.

        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: a = x[0] + x[1]
            sage: hash(a)
            6447839315714024659   # 64-bit
            233743571             # 32-bit
            sage: hash(a._p)
            6447839315714024659   # 64-bit
            233743571             # 32-bit

        """
        return hash(self._p)

    def polynomial(self):
        """
        Return the underlying polynomial

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(GF(7))
            sage: p=x[2]*y[1]+3*y[0]
            sage: p
            y1*x2 + 3*y0
            sage: p.polynomial()
            y1*x2 + 3*y0
            sage: p.polynomial().parent()
            Multivariate Polynomial Ring in y2, y1, y0, x2, x1, x0 over Finite Field of size 7
            sage: p.parent()
            Infinite polynomial ring in x, y over Finite Field of size 7

        """
        return self._p

    def __call__(self, *args, **kwargs):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ,implementation='sparse')
            sage: a = x[0] + x[1]
            sage: a(x0=2,x1=x[1])
            x1 + 2
            sage: _.parent()
            Infinite polynomial ring in x over Rational Field
            sage: a(x1=3)
            x0 + 3
            sage: _.parent()
            Infinite polynomial ring in x over Rational Field

            sage: a(x1=x[100])
            x100 + x0

        """
        #Replace any InfinitePolynomials by their underlying polynomials
        if hasattr(self._p,'variables'):
            V = [str(x) for x in self._p.variables()]
        else:
            V = []
        for kw in kwargs:
            value = kwargs[kw]
            if isinstance(value, InfinitePolynomial_sparse):
                kwargs[kw] = value._p
                V.append(kw)
                if hasattr(value._p,'variables'):
                    V.extend([str(x) for x in value._p.variables()])
        args = list(args)
        for i, arg in enumerate(args):
            if isinstance(arg, InfinitePolynomial_sparse):
                args[i] = arg._p
                if hasattr(arg._p,'variables'):
                    V.extend([str(x) for x in arg._p.variables()])
        V=list(set(V))
        V.sort(cmp=self.parent().varname_cmp,reverse=True)
        if V:
            from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
            R = PolynomialRing(self._p.base_ring(),V,order=self.parent()._order)
        else:
            return self
        res = R(self._p)(*args, **kwargs)
        if self.parent().has_coerce_map_from(res.parent()):
            res = self.parent()(res)
        return res

    def __dir__(self):
        """
        This method implements tab completion, see ticket #6854.

        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: import sagenb.misc.support as s
            sage: p = x[3]*x[2]
            sage: s.completions('p.co',globals(),system='python') # indirect doc test
            ['p.coefficient', 'p.coefficients', 'p.constant_coefficient', 'p.content']

        """
        return dir(self._p)

    def __getattr__(self, s):
        """
        Many attributes of elements of Infinite Polynomial Rings
        are not genuine, but are inherited from the underlying
        'finite' polynomial, so, for example, the ``_latex_`` or
        ``constant_coefficient`` methods.

        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: latex(x[3]*x[2]^2) # indirect doctest
            x_{3} x_{2}^{2}

        Related with ticket #6854, the attribute ``__members__``
        is specially treated, which allows for introspection::

            sage: 'constant_coefficient' in dir(x[3]*x[2]^2) # indirect doctest
            True

        """
        try:
            return getattr(self._p,s)
        except AttributeError:
            raise AttributeError, '%s has no attribute %s'%(self.__class__, s)

    def ring(self):
        """
        The ring which self belongs to. This is the same as ``self.parent()``.

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ,implementation='sparse')
            sage: p = x[100]*y[1]^3*x[1]^2+2*x[10]*y[30]
            sage: p.ring()
            Infinite polynomial ring in x, y over Rational Field

        """
        return self.parent()

    @cached_method
    def variables(self):
        """
        Return the variables occurring in self (tuple of elements of some polynomial ring)

        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: p = x[1] + x[2] - 2*x[1]*x[3]
            sage: p.variables()
            (x3, x2, x1)
            sage: x[1].variables()
            (x1,)
            sage: X(1).variables()
            ()

        """
        if hasattr(self._p, 'variables'):
            return tuple(self._p.variables())
        return ()

    @cached_method
    def max_index(self):
        r"""
        Return the maximal index of a variable occurring in self, or -1 if self is scalar

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: p=x[1]^2+y[2]^2+x[1]*x[2]*y[3]+x[1]*y[4]
            sage: p.max_index()
            4
            sage: x[0].max_index()
            0
            sage: X(10).max_index()
            -1
        """
        return max([Integer(str(X)[1:]) for X in self.variables()]+[-1])

    # Basic arithmetics
    def _add_(self, x):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: x[1] + x[2]
            x2 + x1

        """
        if self._p.parent().has_coerce_map_from(x._p.parent()):
            return InfinitePolynomial_sparse(self.parent(),self._p+x._p, is_good_poly=True)
        if not (hasattr(self._p,'variables') and hasattr(x._p,'variables')):
            R1 = self._p.parent()
            R2 = x._p.parent()
            if R1.has_coerce_map_from(R2) or R2.has_coerce_map_from(R1):
                return InfinitePolynomial_sparse(self.parent(), self._p + x._p, is_good_poly=True)
        #VarList = list(set([str(X) for X in self._p.variables()]+[str(X) for X in x._p.variables()]))
        VarList = list(set(self._p.parent().variable_names()+ x._p.parent().variable_names()))
        VarList.sort(cmp=self.parent().varname_cmp,reverse=True)
        if VarList:
            from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
            R = PolynomialRing(self._p.base_ring(),VarList,order=self.parent()._order)
        else:
            R = self._p.base_ring()
        return InfinitePolynomial_sparse(self.parent(),R(self._p) + R(x._p), is_good_poly=True)

    def _mul_(self, x):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: x[2]*x[1]
            x2*x1

        """
        if self._p.parent().has_coerce_map_from(x._p.parent()):
            return InfinitePolynomial_sparse(self.parent(),self._p*x._p, is_good_poly=True)
        if not (hasattr(self._p,'variables') and hasattr(x._p,'variables')):
            R1 = self._p.parent()
            R2 = x._p.parent()
            if R1.has_coerce_map_from(R2) or R2.has_coerce_map_from(R1):
                return InfinitePolynomial_sparse(self.parent(), self._p * x._p, is_good_poly=True)
        VarList = list(set(self._p.parent().variable_names()+ x._p.parent().variable_names()))
        VarList.sort(cmp=self.parent().varname_cmp,reverse=True)
        if VarList:
            from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
            R = PolynomialRing(self._p.base_ring(),VarList,order=self.parent()._order)
        else:
            R = self._p.base_ring()
        return InfinitePolynomial_sparse(self.parent(),R(self._p) * R(x._p), is_good_poly=True)


    def _div_(self, x):
        """
        Division of Infinite Polynomials. Note that the divisor must
        be scalar -- Infinite Fraction Fields are not implemented yet.

        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: x[0]/2
            1/2*x0
            sage: x[0]/x[0]
            Traceback (most recent call last):
            ...
            NotImplementedError: Fraction Fields of Infinite Polynomial Rings are not implemented

        """
        if hasattr(x._p,'variables'):
            if x._p.variables():
                raise NotImplementedError, "Fraction Fields of Infinite Polynomial Rings are not implemented"
        return InfinitePolynomial_sparse(self.parent(), self._p/self._p.base_ring()(x._p), is_good_poly=True)

    def _sub_(self, x):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: x[2] - x[1]
            x2 - x1

        """
        if self._p.parent().has_coerce_map_from(x._p.parent()):
            return InfinitePolynomial_sparse(self.parent(),self._p-x._p, is_good_poly=True)
        if not (hasattr(self._p,'variables') and hasattr(x._p,'variables')):
            R1 = self._p.parent()
            R2 = x._p.parent()
            if R1.has_coerce_map_from(R2) or R2.has_coerce_map_from(R1):
                return InfinitePolynomial_sparse(self.parent(), self._p - x._p, is_good_poly=True)
        VarList = list(set(self._p.parent().variable_names()+ x._p.parent().variable_names()))
        VarList.sort(cmp=self.parent().varname_cmp,reverse=True)
        if VarList:
            from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
            R = PolynomialRing(self._p.base_ring(),VarList, order=self.parent()._order)
        else:
            R = self._p.base_ring()
        return InfinitePolynomial_sparse(self.parent(),R(self._p) - R(x._p), is_good_poly=True)

    def __pow__(self, n):
        """
        Exponentiation by an integer, or action by a callable object

        NOTE::

            The callable object must accept non-negative integers as input
            and return non-negative integers. Typical use case is a permutation,
            that will result in the corresponding permutation of variables.

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: x[10]^3
            x10^3
            sage: p = x[10]*y[2]+2*x[1]*y[3]
            sage: P = Permutation(((1,2),(3,4,5)))
            sage: p^P
            2*y4*x2 + y1*x10

        """
        P = self.parent()
        if callable(n):
            if (self._p.parent() == self._p.base_ring()):
                return self
            if not (hasattr(self._p,'variables') and self._p.variables()):
                return self
            if hasattr(n,'to_cycles') and hasattr(n,'__len__'): # duck typing Permutation_class
                # auxiliary function, necessary since n(m) raises an error if m>len(n)
                l = len(n)
                p = lambda m: n(m) if 0<m<=l else m
            else: # Permutation group element
                p = n
            q = lambda s: s[0]+str(p(ZZ(s[1:])))
            newVars = [q(X) for X in self._p.parent().variable_names()]
            if not newVars:
                return self
            copyVars = copy.copy(newVars)
            newVars = list(set(list(self._p.parent().variable_names())+newVars))
            newVars.sort(cmp=self.parent().varname_cmp, reverse=True)
            if newVars == list(self._p.parent().variable_names()):
                newR = self._p.parent()
            else:
                from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
                newR = PolynomialRing(self._p.base_ring(), newVars,order=P._order)
            mapR = self._p.parent().hom(copyVars,newR)
            return InfinitePolynomial_sparse(self.parent(), mapR(self._p), is_good_poly=True)
        return InfinitePolynomial_sparse(self.parent(), self._p**n, is_good_poly=True)

    # Basic tools for Buchberger algorithm:
    # order, leading term/monomial, symmetric cancellation order
    def __cmp__(self, x):
        """
        Comparison of Infinite Polynomials

        NOTE:

            Let x and y are generators of the parent of self. We only consider
            monomial orderings in which
            x[m] < y[n] iff x appears earlier in the list of generators than y, or
                            x==y and m<n
            Under this restriction, the monomial ordering can be 'lex' (default)
            or 'deglex'.

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: a = x[10]^3
            sage: b = x[1] + x[2]
            sage: c = x[1] + x[2]
            sage: d = y[1] + x[2]
            sage: a == a
            True
            sage: b == c
            True
            sage: a == b
            False
            sage: c<d
            True

        """
        P = self.parent()
        try:
            x = P(x)
        except ValueError:
            return -1
        # We can assume that self.parent() is x.parent(),
        # but of course the underlying polynomial rings
        # may be widely different.
        R1 = self._p.parent()
        R2 = x._p.parent()
        if R1.has_coerce_map_from(R2) or R2.has_coerce_map_from(R1):
            return cmp(self._p, x._p)
        VarList = list(set(list(self._p.parent().variable_names())+list(x._p.parent().variable_names())))
        VarList.sort(cmp=self.parent().varname_cmp,reverse=True)
        if VarList:
            from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
            R = PolynomialRing(self._p.base_ring(),VarList,order=self.parent()._order)
        else:
            R = self._p.base_ring()
        if (self._p.parent() is self._p.base_ring()) or not self._p.parent().gens():
                fself = self._p.base_ring()
        else:
            fself = self._p.parent().hom(self._p.parent().variable_names(),R)
        if (x._p.parent() is x._p.base_ring()) or not x._p.parent().gens():
                fx = x._p.base_ring()
        else:
            fx = x._p.parent().hom(x._p.parent().variable_names(),R)
        return cmp(fself(self._p), fx(x._p))

    @cached_method
    def lm(self):
        """
        The leading monomial of self

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: p = 2*x[10]*y[30]+x[10]*y[1]^3*x[1]^2
            sage: p.lm()
            y30*x10

        """
        if hasattr(self._p,'lm'):
            return InfinitePolynomial(self.parent(), self._p.lm(), is_good_poly=True)
        if self._p==0:
            return self
        if hasattr(self._p,'variable_name'): # if it is univariate
            return InfinitePolynomial(self.parent(),self._p.parent().gen()**max(self._p.exponents()), is_good_poly=True)
        return self # if it is scalar

    @cached_method
    def lc(self):
        """
        The coefficient of the leading term of self

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: p = 2*x[10]*y[30]+3*x[10]*y[1]^3*x[1]^2
            sage: p.lc()
            2

        """
        if hasattr(self._p,'lc'):
            return self._p.lc()
        if hasattr(self._p,'variable_name'): # univariate case
            return self._p.leading_coefficient()
        # scalar case
        return self._p

    @cached_method
    def lt(self):
        """
        The leading term (= product of coefficient and monomial) of self

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: p = 2*x[10]*y[30]+3*x[10]*y[1]^3*x[1]^2
            sage: p.lt()
            2*y30*x10

        """
        if hasattr(self._p,'lt'):
            return InfinitePolynomial(self.parent(), self._p.lt(), is_good_poly=True)
        if self._p==0:
            return self
        if hasattr(self._p,'variable_name'): # if it is univariate
            return InfinitePolynomial(self.parent(), self._p.leading_coefficient()*self._p.parent().gen()**max(self._p.exponents()), is_good_poly=True)
        return self # if it is scalar

    def tail(self):
        """
        The tail of self (this is self minus its leading term)

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: p = 2*x[10]*y[30]+3*x[10]*y[1]^3*x[1]^2
            sage: p.tail()
            3*y1^3*x10*x1^2

        """
        return self-self.lt()

    def squeezed(self):
        """
        Reduce the variable indices occurring in self

        OUTPUT:
            Apply a permutation to self that does not change the
            order of the variable indices of self but squeezes them
            into the range 1,2,...

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ,implementation='sparse')
            sage: p = x[1]*y[100] + x[50]*y[1000]
            sage: p.squeezed()
            y4*x2 + y3*x1

        """
        Indices = set([0]+[Integer(str(Y)[1:]) for Y in self.variables()])
        Indices = list(Indices)
        Indices.sort()
        P = lambda n: Indices.index(n) if Indices.__contains__(n) else n
        return self**P

    def footprint(self):
        """
        Leading exponents in increasing order sorted by generator names

        OUTPUT:
            ``D`` -- a dictionary whose keys are the occurring variable indices.

            ``D[s]`` is a list ``[i_1,...,i_n]``, where ``i_j`` gives the
            exponent of ``self.parent().gen(j)[s]`` in the leading
            term of self.

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: p = x[30]*y[1]^3*x[1]^2+2*x[10]*y[30]
            sage: p.footprint()
            {10: [1, 0], 30: [0, 1]}

        """
        if not self._has_footprint:
            PARENT = self.parent()
            l = len(self.parent()._names)
            # get the pairs (shift,exponent) of the leading monomial, indexed by the variable names
            L = [PARENT._exppattern.split(X) for X in PARENT._monpattern.findall(str(self.lm()))]
            for t in L:
                n = t[0][0]       # the variable *n*ame
                s = int(t[0][1:]) # the variable *s*hift
                if not self._footprint.has_key(s):
                    self._footprint[s] = [0]*l
                if len(t)==2:
                    self._footprint[s][self.parent()._name_dict[n]] = int(t[1])     # the exponent
                else:
                    self._footprint[s][self.parent()._name_dict[n]] = 1     # the exponent
            self._has_footprint = True
        return self._footprint

    def symmetric_cancellation_order(self,other):
        """
        Comparison of leading terms by Symmetric Cancellation Order, `<_{sc}`

        INPUT:
            self, other -- two Infinite Polynomials

        ASSUMPTION:
            Both Infintie Polynomials are non-zero

        OUTPUT:
            ``(c, sigma, w)``, where

            * c = -1,0,1, or None if the leading monomial of ``self`` is smaller, equal,
              greater, or incomparable with respect to ``other`` in the monomial
              ordering of the Infinite Polynomial Ring
            * sigma is a permutation witnessing
              ``self`` `<_{sc}` ``other`` (resp. ``self`` `>_{sc}` ``other``)
              or is 1 if ``self.lm()==other.lm()``
            * w is 1 or is a term so that
              ``w*self.lt()^sigma == other.lt()`` if `c\\le 0`, and
              ``w*other.lt()^sigma == self.lt()`` if `c=1`

        THEORY:
            If the Symmetric Cancellation Order is a well-quasi-ordering
            then computation of Groebner bases always terminates. This is
            the case, e.g., if the monomial order is lexicographic. For
            that reason, lexicographic order is our default order.

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: (x[2]*x[1]).symmetric_cancellation_order(x[2]^2)
            (None, 1, 1)
            sage: (x[2]*x[1]).symmetric_cancellation_order(x[2]*x[3]*y[1])
            (-1, [2, 3, 1], y1)
            sage: (x[2]*x[1]*y[1]).symmetric_cancellation_order(x[2]*x[3]*y[1])
            (None, 1, 1)
            sage: (x[2]*x[1]*y[1]).symmetric_cancellation_order(x[2]*x[3]*y[2])
            (-1, [2, 3, 1], 1)

        """
        PARENT = self.parent()
        other = PARENT(other)
        slt = self.lt()
        olt = other.lt()
        rawcmp = cmp(self.lm(),other.lm())
        if rawcmp == 0:
            if olt==0:
                return (0, 1, 1)
            return (0, 1, self.lc()/other.lc())
        if rawcmp == -1:
            Fsmall = dict([[k[0], [e for e in k[1]]] for k in self.footprint().items()])
            Fbig = dict([[k[0], [e for e in k[1]]] for k in other.footprint().items()])
            ltsmall = slt
            ltbig = olt
        else:
            Fbig = dict([[k[0], [e for e in k[1]]] for k in self.footprint().items()])
            Fsmall = dict([[k[0], [e for e in k[1]]] for k in other.footprint().items()])
            ltbig = slt
            ltsmall = olt
        # Case 1: one of the Infintie Polynomials is scalar.
        if not Fsmall:
            return (rawcmp, 1, ltbig/ltsmall)
        # "not Fbig" is now impossible, because we only consider *global* monomial orderings.
        # These are the occurring shifts:
        Lsmall = Fsmall.keys()
        Lsmall.sort()
        Lbig   = Fbig.keys()
        Lbig.sort()
        P = range(Lbig[-1]+1)
        gens = xrange(PARENT.ngens())
        if Lsmall[0]==0:
            if not Fbig.has_key(0):
                return (None,1,1)
            Lsmall.pop(0)
            Lbig.pop(0)
            ExpoSmall = Fsmall[0]
            ExpoBig = Fbig[0]
            for k in gens:
                if ExpoBig[k]<ExpoSmall[k]:
                    return (None,1,1)
                ExpoBig[k]-=ExpoSmall[k]
        lenBig = len(Lbig)
        j = -1              # will have Lbig[j] -- a shift of the bigger polynomial
        for i in Lsmall:   # i is a shift of the smaller polynomial
            j += 1
            ExpoSmall = Fsmall[i]
            while (j<lenBig):
                found = False
                if Lbig[j]>=i:
                    ExpoBigSave = [e for e in Fbig[Lbig[j]]]
                    ExpoBig = Fbig[Lbig[j]]
                    found = True
                    for k in gens:
                        if ExpoBig[k]<ExpoSmall[k]:
                            found = False
                            Fbig[Lbig[j]] = ExpoBigSave
                            break
                        ExpoBig[k]-=ExpoSmall[k]
                if found:
                    break
                j+=1
            if j==lenBig:
                return (None,1,1)  ## no "increasing" permutation transforms
                                    ## the smaller monomial into a factor of
                                    ## the bigger monomial
            tmp = P[i]
            P[i] = Lbig[j]
            P[Lbig[j]]=tmp
        # now, P defines an 'up-shift' permutation, slt^P divides olt, and
        # Fbig contains the exponents for olt/slt^P.
        OUT = PARENT(PARENT._base(ltbig.lc()/ltsmall.lc()))
        for shift, Expo in Fbig.items():
            for g in gens:
                if Expo[g]:
                    OUT *= PARENT.gen(g)[shift].__pow__(Expo[g])
        from sage.combinat.permutation import Permutation
        return (rawcmp, Permutation(P[1:]), OUT)

    def coefficient(self, monomial):
        """
        Returns the coefficient of a monomial in this polynomial.

        INPUT:

        - A monomial (element of the parent of self) or
        - a dictionary that describes a monomial (the keys
           are variables of the parent of self, the values
           are the corresponding exponents)

        EXAMPLES:

        We can get the coefficient in front of monomials::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: a = 2*x[0]*x[1] + x[1] + x[2]
            sage: a.coefficient(x[0])
            2*x1
            sage: a.coefficient(x[1])
            2*x0 + 1
            sage: a.coefficient(x[2])
            1
            sage: a.coefficient(x[0]*x[1])
            2

        We can also pass in a dictionary::

            sage: a.coefficient({x[0]:1, x[1]:1})
            2

        """
        if self._p==0:
            res = 0
        elif isinstance(monomial, self.__class__):
            if not (self.parent().has_coerce_map_from(monomial.parent())):
                res = 0
            else:
                if hasattr(self._p,'variables'):
                    VarList = [str(X) for X in self._p.variables()]
                else:
                    VarList = []
                if hasattr(monomial._p,'variables'):
                    VarList.extend([str(X) for X in monomial._p.variables()])
                VarList = list(set(VarList))
                VarList.sort(cmp=self.parent().varname_cmp,reverse=True)
                from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
                if len(VarList)==1:
                    R = PolynomialRing(self._p.base_ring(),VarList+['xx'],order=self.parent()._order)
                                                                 ## 'xx' is guaranteed to be no variable
                                                                 ## name of monomial, since coercions
                                                                 ## were tested before
                    res = PolynomialRing(self._p.base_ring(),VarList,order=self.parent()._order)(R(self._p).coefficient(R(monomial._p)))
                else:
                    R = PolynomialRing(self._p.base_ring(),VarList,order=self.parent()._order)
                    res = R(self._p).coefficient(R(monomial._p))
        elif isinstance(monomial, dict):
            if monomial:
                I = monomial.iterkeys()
                K = I.next()
                monomial.__delitem__(K)
                res = self.coefficient(K).coefficient(monomial)
            else:
                return self
        else:
            raise TypeError, "Objects of type %s have no coefficients in InfinitePolynomials"%(type(monomial))
        return InfinitePolynomial(self.parent(), res, is_good_poly=True)

    ## Essentials for Buchberger
    def reduce(self, I, tailreduce=False, report=None):
        """
        Symmetrical reduction of self with respect to a symmetric ideal (or list of Infinite Polynomials)

        Reducing an element `p` of an Infinite Polynomial Ring `X` by some other element `q`
        means the following:

        1. Let `M` and `N` be the leading terms of `p` and `q`.
        2. Test whether there is a permutation `P` that does not does not diminish the variable
           indices occurring in `N` and preserves their order, so that there is some term `T\in X`
           with `TN ^P = M`. If there is no such permutation, return `p`
        3. Replace `p` by `p-T q^P` and continue with step 1.

        INPUT:

        - I -- a :class:`~sage.rings.polynomial.symmetric_ideal.SymmetricIdeal` or a list
          of Infinite Polynomials
        - Sometimes it is useful to reduce not only the leading term of `p`.
          This *tail reduction* is performed if the optional parameter ``tailreduce`` is True.
        - If the optional parameter ``report`` is not None, some information on the progress
          of computation is given, since reduction of huge polynomials may be expensive.

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: p = y[1]^2*y[3]+y[1]*x[3]
            sage: p.reduce([y[2]^2*y[1]])
            y3*y1^2 + y1*x3

        The preceding is correct, since any permutation that turns ``y[2]^2*y[1]`` into
        a factor of ``y[1]^2*y[3]`` interchanges the variable indices 1 and 2 -- which is not
        allowed. However, reduction by ``y[1]^2*y[2]`` works, since one can change variable
        index 1 into 2 and 2 into 3::

            sage: p.reduce([y[1]^2*y[2]])
            y1*x3

        The next example shows that tail reduction is not done, unless it is explicitly advised.
        The input can also be a Symmetric Ideal::

            sage: I = (x[2])*X
            sage: p.reduce(I)
            y3*y1^2 + y1*x3
            sage: p.reduce(I, tailreduce=True)
            y3*y1^2

        Last, we demonstrate the ``report`` option::

            sage: p=x[1]^2+y[2]^2+x[1]*x[2]*y[3]+x[1]*y[4]
            sage: p.reduce(I, tailreduce=True, report=True)
            T[3]:>
            >
            y4*x1 + y2^2 + x1^2

        The output 'T[3]' means that tail reduction is performed on a polynomial with three terms.
        ':' means that there was one reduction of the leading monomial.
        At '>', one round of the reduction process is finished.

        """
        from sage.rings.polynomial.symmetric_reduction import SymmetricReductionStrategy
        if hasattr(I,'gens'):
            I = I.gens()
        if (not I):
            return self
        I = list(I)
        S = SymmetricReductionStrategy(self.parent(),I, tailreduce)
        return S.reduce(self, report=report)

    ## Further methods
    def stretch(self, k):
        """
        Replace `v_n` with `v_{n\\cdot k}` for all generators `v_\\ast` occurring in self.

        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: a = x[0] + x[1] + x[2]
            sage: a.stretch(2)
            x4 + x2 + x0

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: a = x[0] + x[1] + y[0]*y[1]; a
            y1*y0 + x1 + x0
            sage: a.stretch(2)
            y2*y0 + x2 + x0

        TESTS::

            sage: X.<x> = InfinitePolynomialRing(QQ, implementation='sparse')
            sage: a = x[2] + x[3]
            sage: a.stretch(2000)
            x6000 + x4000

        """
        P = lambda n: k*n
        return self.__pow__(P)


class InfinitePolynomial_dense(InfinitePolynomial_sparse):
    """
    Element of a dense Polynomial Ring with a Countably Infinite Number of Variables

    INPUT:

    - ``X``, an Infinite Polynomial Ring in dense implementation
    - ``p``, which is either an Infinite Polynomial, a *classical* polynomial, a string,
      or anything else that can be interpreted in ``X``.

    If the optional parameter ``is_good_poly`` is given, then it is assumed that ``p`` is
    a *classical* polynomial that can be interpreted in ``X``. Otherwise, the input is checked.

    This class inherits from :class:`~sage.rings.polynomial.infinite_polynomial_element.InfinitePolynomial_sparse`.
    See there for a description of the methods.
    """
    # Construction and other basic methods
    def __init__(self, A, p, is_good_poly=False):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: a = x[1] + x[2]
            sage: a == loads(dumps(a))
            True

        """
        if is_good_poly:
            self._p = A._P(p)
            self._has_footprint = False
            self._footprint = {}
            RingElement.__init__(self, A)
            return
        ## Try to find an appropriate ring
        # Case 1: string
        elif isinstance(p,basestring):
            #print 'use string'
            VarList = list(set(A._varpattern.findall(p)))
            newMax = max([Integer(X[1:]) for X in VarList]+[0])
            if newMax > A._max:
                A.gen()[newMax]
        # Case 2: python int and those things
        elif (not hasattr(p,'parent')) or (not hasattr(p,'variables')): # catch the case of p=int(1) or p=Integer(1) etc
            #print 'python int'
            pass
        # Case 3: InfinitePolynomial
        elif isinstance(p, InfinitePolynomial_sparse):
            #print 'infinite poly'
            newMax = p.max_index()
            if newMax > A._max:
                A.gen()[newMax]
            p = p._p
        # Case 4: polynomial
        else: # now, p is supposed to be a polynomial. Otherwise, an error will occur
            #print 'classical poly'
            newMax = max([Integer(str(X)[1:]) for X in p.variables()]+[0])
            if newMax > A._max:
                A.gen()[newMax]

        ## Now, the underlying polynomial ring is updated and comprises p
        self._p = A._P(p)
        self._has_footprint = False
        self._footprint = {}
        RingElement.__init__(self, A)

    def __call__(self, *args, **kwargs):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: a = x[0] + x[1]
            sage: a(x0=2,x1=x[1])
            x1 + 2
            sage: _.parent()
            Infinite polynomial ring in x over Rational Field
            sage: a(x1=3)
            x0 + 3
            sage: _.parent()
            Infinite polynomial ring in x over Rational Field

            sage: a(x1=x[100])
            x100 + x0

        """
        #Replace any InfinitePolynomials by their underlying polynomials
        for kw in kwargs:
            value = kwargs[kw]
            if isinstance(value, InfinitePolynomial_sparse):
                kwargs[kw] = value._p
        args = list(args)
        for i, arg in enumerate(args):
            if isinstance(arg, InfinitePolynomial_sparse):
                args[i] = arg._p
        self._p = self.parent().polynomial_ring()(self._p)
        res = self._p(*args, **kwargs)
        try:
            return self.parent()(res)
        except ValueError:
            return res

    def __cmp__(self, x):
        """
        """
        P = self.parent()
        try:
            x = P(x)
        except ValueError:
            return -1
        # We can not assume yet that self._p and
        # x._p are already defined over self.parent()._P
        # It won't hurt to change self in place.
        self._p = P._P(self._p)
        return cmp(self._p,x._p)

    # Basic arithmetics
    def _add_(self, x):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: x[1] + x[2]
            x2 + x1

        """
        P = self.parent()
        self._p = P._P(self._p)
        x._p = P._P(x._p)
        return InfinitePolynomial_dense(self.parent(),self._p + x._p, is_good_poly=True)

    def _mul_(self, x):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: x[2]*x[1]
            x2*x1

        """
        P = self.parent()
        self._p = P._P(self._p)
        x._p = P._P(x._p)
        return InfinitePolynomial_dense(self.parent(),self._p * x._p, is_good_poly=True)


    def _div_(self, x):
        """
        Division of Infinite Polynomials. Note that the divisor must
        be scalar -- Infinite Fraction Fields are not implemented yet.

        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: x[0]/2
            1/2*x0
            sage: x[0]/x[0]
            Traceback (most recent call last):
            ...
            NotImplementedError: Fraction Fields of Infinite Polynomial Rings are not implemented

        """
        if hasattr(x._p,'variables'):
            if x._p.variables():
                raise NotImplementedError, "Fraction Fields of Infinite Polynomial Rings are not implemented"
        if hasattr(x._p,'lc'): # this works around a bug in multipolynomial rings over fraction fields
            return InfinitePolynomial_dense(self.parent(), self._p/x._p.lc(), is_good_poly=True)
        return InfinitePolynomial_dense(self.parent(), self._p/self._p.base_ring()(x._p), is_good_poly=True)

    def _sub_(self, x):
        """
        EXAMPLES::

            sage: X.<x> = InfinitePolynomialRing(QQ)
            sage: x[2] - x[1]
            x2 - x1

        """
        P = self.parent()
        self._p = P._P(self._p)
        x._p = P._P(x._p)
        return InfinitePolynomial_dense(self.parent(), self._p - x._p, is_good_poly=True)

    def __pow__(self, n):
        """
        Exponentiation by an integer, or action by a callable object

        NOTE::

            The callable object must accept non-negative integers as input
            and return non-negative integers. Typical use case is a permutation,
            that will result in the corresponding permutation of variables.

        EXAMPLES::

            sage: X.<x,y> = InfinitePolynomialRing(QQ)
            sage: x[10]^3
            x10^3
            sage: p = x[10]*y[2]+2*x[1]*y[3]
            sage: P = Permutation(((1,2),(3,4,5)))
            sage: p^P
            2*y4*x2 + y1*x10

        """
        P = self.parent()
        if callable(n):
            if (self._p.parent() == self._p.base_ring()):
                return self
            if not (hasattr(self._p,'variables') and self._p.variables()):
                return self
            if hasattr(n,'to_cycles') and hasattr(n,'__len__'): # duck typing Permutation_class
                # auxiliary function, necessary since n(m) raises an error if m>len(n)
                l = len(n)
                p = lambda m: n(m) if 0<m<=l else m
            else: # Permutation group element
                p = n
            # determine whether the maximal index must be raised
            newMax = max([p(X) for X in range(P._max+1)]+[P._max])
            if newMax > P._max:
                P.gen()[newMax]
            # next, determine the images of variable names
            PP = P._P
            newVars = []
            sh = newMax
            nM = newMax+1
            PPgens = PP.gens()
            for i in range(P.ngens()):
                newVars.extend([PPgens[sh-p(j)] for j in range(newMax,-1,-1)])
                sh += nM
            mapR = PP.hom(newVars, PP)
            return InfinitePolynomial_dense(self.parent(), mapR(self._p), is_good_poly=True)
        return InfinitePolynomial_dense(self.parent(), self._p**n, is_good_poly=True)
