r"""
 AUTHORS:
     -- Martin Albrecht <malb@informatik.uni-bremen.de> (2006-06-05)
"""


#*****************************************************************************
#
#   SAGE: System for Algebra and Geometry Experimentation
#
#       Copyright (C) 2006 William Stein <wstein@ucsd.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/
#*****************************************************************************


#header{
#include <iostream>
#include <sstream>
#include <vector>
#include <linbox/field/givaro-gfq.h>
#include <linbox/integer.h>
using namespace LinBox;
using namespace std;

#}header

cdef extern from "stdlib.h":
    void free(void *ptr)

#################################
#cdef int _sig_on
#cdef int _sig_off
#cdef int _sig_check
include 'interrupt.pxi'
#################################

include 'misc.pxi'

from sage.ext.ring cimport FiniteField
from sage.rings.coerce import bin_op
import operator

cdef class GFq_element # forward declaration

cdef class GFq(FiniteField):
    cdef void *thisptr
    cdef int repr

    def __init__(GFq self, q,name="a",  poly=None, repr="int"):
        """
        Givaro Finite Field. These are implemented using Zech logs and
        therefor the cardinality must be < 2^20.

        INPUT:
            q     -- p^n (must be prime power)
            name -- variable used for poly_repr (default: 'a')
            poly  -- you may provide a minimal polynomial to use for
                     reduction. (default: None, so a random polynomial will be
                     used by the Givaro library)
            repr  -- controls the way elements are represented to the user:
                     'log': repr is element.log_repr()
                     'int': repr is element.int_repr()
                     'poly': repr is element.poly_repr()
                     (default: 'int')


        OUTPUT:
            Givaro finite field with characteristic p and cardinality p^n.
        """

        from sage.rings.polynomial_element import is_Polynomial
        import sage.databases.conway
        from sage.rings.finite_field import conway_polynomial
        from sage.ext.integer import Integer

        #embed{ void *GFq_initpk(int p, int k)
        return new GivaroGfq(p,k);
        #}embed

        #embed{ void *GFq_initpkp(int p, int k, void *poly)
        return new GivaroGfq(p,k,*(vector<integer>*)poly);
        #}embed

        cdef void *cPoly

        if repr=='poly':
            self.repr = 0
        elif repr=='log':
            self.repr = 1
        else:
            self.repr = 2

        q = Integer(q)
        if q < 2:
            raise ArithmeticError, "q (=%s) must be a prime power"%q
        F = q.factor()
        if len(F) > 1:
            raise ArithmeticError, "q (=%s) must be a prime power"%q
        p = F[0][0]
        k = F[0][1]

        self.assign_names(name)

        if poly==None or poly=="random":
            if k>1 and sage.databases.conway.ConwayPolynomials().has_polynomial(p, k) and poly!="random":
                poly = conway_polynomial(p, k)
            else:
                _sig_on
                self.thisptr = GFq_initpk(p,k)
                _sig_off
                return

        if is_Polynomial(poly):
            poly = poly.list()

        if isinstance(poly,list) or isinstance(poly,tuple):
            #embed{ void *vec_init(int len)
            vector<integer> *cPoly = new vector<integer>(len);
            return cPoly;
            #}embed

            #embed{ void *vec_set(void *vec,int i, int value)
            (*(vector<integer>*)vec)[i]=integer(value);
            #}embed

            #embed{ void vec_del(void *vec)
            delete ((vector<integer>*)vec);
            #}embed

            cPoly = vec_init(len(poly))

            for i from 0 <= i < len(poly):
                vec_set(cPoly,i,int(poly[i]))

            _sig_on
            self.thisptr = GFq_initpkp(p,k,cPoly)
            _sig_off
            vec_del(cPoly)
            return

        raise TypeError, "Cannot understand %s"%(poly)



    def __dealloc__(GFq self):
        """
        """
        #embed{ void delete_GFq( void *obj)
        if(obj) {
            delete ((GivaroGfq*)obj);
        }
        #}embed

        delete_GFq(self.thisptr)

    def __repr__(GFq self):
        return "Givaro Finite Field of size %d^%d"%(self.characteristic(),self.degree())


##     def residu(GFq self):
##         """
##         """
##         #embed{ int GFq_residu(void *obj)
##         return ((GivaroGfq*)obj)->residu();
##         #}embed

##         return int(GFq_residu(self.thisptr))


    def characteristic(GFq self):
        """
        Return integer representing characteristic of the domain.
        Returns a positive integer to all domains with finite
        characteristic, and returns 0 to signify a domain of infinite
        characteristic.

        OUTPUT:
            integer representing characteristic of the domain.
        """
        #embed{ unsigned int GFq_characteristic(void *obj)
        return ((GivaroGfq*)obj)->characteristic();
        #}embed

        return int(GFq_characteristic(self.thisptr))

    def order(GFq self):
        return self.cardinality()

    def cardinality(GFq self):
        """
        Return integer representing cardinality of the domain.
        Returns a non-negative integer for all domains with finite
        cardinality, and returns -1 to signify a domain of infinite
        cardinality.

        OUTPUT:
            integer representing cardinality of the domain
        """
        #embed{ int GFq_cardinality(void *obj)
        return ((GivaroGfq*)obj)->cardinality();
        #}embed

        return int(GFq_cardinality(self.thisptr))

    def degree(GFq self):
        """
        If self.cardinality() == p^n this method returns n.

        OUTPUT:
             log_{self.characteristic()}(self.cardinality())
        """
        #embed{ int GFq_exponent(void *obj)
        return ((GivaroGfq*)obj)->exponent();
        #}embed

        return int(GFq_exponent(self.thisptr))

    def is_atomic_repr(GFq self):
        if self.repr==0: #poly
            return False
        else:
            return True

    def is_prime_field(GFq self):
        """
        """
        return bool(self.degree()==1)

    def random_element(GFq self):
        """
        """
        #embed{ int GFq_random_element(void *obj)
        GivaroGfq::Element res;
        GivRandom generator;
        res = ((GivaroGfq*)obj)->random(generator,res);
        return res;
        #}embed

        cdef int res
        res = GFq_random_element(self.thisptr)
        return make_GFq_element(self,res)

    def __call__(GFq self, e):
        """
        Coerces several data types to self.
        """
        from sage.ext.integer import Integer
        from sage.rings.finite_field_element import FiniteFieldElement
        from sage.modules.free_module_element import FreeModuleElement
        from sage.rings.integer_mod import IntegerMod
        from sage.libs.pari.gen import gen

        #embed{ int GFq_element_init()
        GivaroGfq::Element res = GivaroGfq::Element();
        return res;
        #}embed

        #embed{ int GFq_element_initi(void *field, int e)
        GivaroGfq::Element res = GivaroGfq::Element();
        return ((GivaroGfq*)field)->init(res,e);
        #}embed

        #embed{ int GFq_element_initd(void *field, double e)
        GivaroGfq::Element res = GivaroGfq::Element();
        return ((GivaroGfq*)field)->init(res,e);
        #}embed


        cdef int res
        cdef int g
        cdef int x

        if isinstance(e,FiniteFieldElement):
            # reduce FiniteFieldElements to pari
            e = e._pari_()

        ########

        if isinstance(e,Integer) or isinstance(e,int) or isinstance(e,long) or isinstance(e,IntegerMod):
            res = GFq_element_initi(self.thisptr,int(e))

        elif isinstance(e,float):
            res = GFq_element_initd(self.thisptr,e)

        elif isinstance(e,gen):
            e = e.lift().lift()
            try:
                res = self.int2log(e[0])
            except TypeError:
                res = self.int2log(e)

            g = GFq_gen(self.thisptr)

            for i from 0 < i <= e.poldegree():
                # -- axpyin: r <- r + a * x mod p
                #embed{ int GFq_element_axpyin(void *field, int r, int a, int x)
                return ((GivaroGfq*)field)->axpyin(r,a,x);
                #}embed
                x = GFq_element_pow(self.thisptr, g, i);
                res = GFq_element_axpyin(self.thisptr, res, self.int2log(e[i]) , x)

        elif isinstance(e,GFq_element):
            if e.parent() == self:
                return e
            if e.parent() == self.prime_subfield():
                res = self.int2log(int(e))

        elif isinstance(e,str):
            return eval(e.replace("^","**"),{str(self.variable_name()):self.gen()})

        elif isinstance(e,FreeModuleElement):
            ret = self.zero()
            for i in range(len(e)):
                ret = ret + self(int(e[i]))*self.gen()**i
            return ret

        else:
            raise TypeError, "Cannot convert %s of type %s into %s"%(e,type(e),self)

        return make_GFq_element(self,res)

    def one(GFq self):
        """
        Returns 1 element in self, which satisfies 1*p=p for
        every element of self != 0.
        """
        #embed{ int GFq_one(void *field)
        return ((GivaroGfq*)field)->one;
        #}embed
        return make_GFq_element(self,GFq_one(self.thisptr))

    def zero(GFq self):
        """
        Returns 0 element in self, which satisfies 0+p=p for
        every element of self.
        """
        #embed{ int GFq_zero(void *field)
        return ((GivaroGfq*)field)->zero;
        #}embed
        return make_GFq_element(self,GFq_zero(self.thisptr))


    def gen(GFq self, ignored=None):
        """
        Returns a generator of self. All elements x of self are
        expressed as log_{self.gen()}(p) internally.
        """
        #embed{ int GFq_gen(void *field)
        int e;
        return ((GivaroGfq*)field)->gen(e);
        #}embed
        return make_GFq_element(self,GFq_gen(self.thisptr))

    def prime_subfield(GFq self):
        return self.base_ring()

    def base_ring(GFq self):
        return GFq(self.characteristic())

    def log2int(GFq self, int p):
        """
        Given an integer p this method returns i where i satisfies
        self.gen()^p == i.

        INPUT:
            p -- log representation of a finite field element

        OUTPUT:
            integer representation of a finite field element.
        """
        #embed{ int GFq_write(void *field, int p)
        int res;
        return ((GivaroGfq*)field)->write(res,p);
        #}embed
        if p<0:
            raise ArithmeticError, "Cannot deal with negative exponents"
        _sig_on
        ret = int(GFq_write(self.thisptr,p))
        _sig_off
        return ret

    def int2log(GFq self, int p):
        """
        Given an integer p this method returns i where i satisfies
        self.gen()^i==(p\%self.characteristic())

        INPUT:
            p -- integer representation of an finite field element

        OUTPUT:
            log representation of p
        """
        #embed{ int GFq_read(void *field, int p)
        int res;
        return ((GivaroGfq*)field)->read(res,p);
        #}embed
        _sig_on
        ret =  int(GFq_read(self.thisptr,p))
        _sig_off
        return ret

    def polynomial(self,r=None):
        """
        Minimal polynomial of self in self.polynomial_ring().
        """

        quo = int(-(self.gen()**(self.degree())))
        b   = int(self.characteristic())

        ret = []
        for i in range(self.degree()):
            ret.append(quo%b)
            quo = quo/b
        ret = ret + [1]

        if r==None:
            r = self.polynomial_ring()

        return r(ret)

    def modulus(self):
        """
        Minimal polynomial of self in self.polynomial_ring().
        """
        return self.polynomial()

    def polynomial_ring(self):
        """
        Returns the polynomial ring over the prime subfield in the
        same variable as this finite field.
        """
        from sage.rings.polynomial_ring import PolynomialRing
        #from sage.rings.finite_field import GF
        return PolynomialRing(GFq(self.characteristic()))

    def _sage_(self):
        """
        Returns a SAGE Finite Field (which is a FiniteField_ext_pari)
        matching self.
        """
        from sage.rings.finite_field import FiniteField_ext_pari
        return FiniteField_ext_pari(self.cardinality(),'a',self.polynomial())

    def vector_space(GFq_element self):
         """
         """
         import sage.modules.all
         V = sage.modules.all.VectorSpace(self.prime_subfield(),self.degree())
         return V

    def __iter__(GFq self):
        if self.degree()>1:
            return FiniteField.__iter__(self)
        else:
            return GFq_iterator(self)

    def __cmp__(GFq self, other):
        if not isinstance(other,GFq):
            return 1
        if self.characteristic()!=other.characteristic():
            return 1
        if self.degree()!=other.degree():
            return 1
        if self.degree()>1:
            if self.polynomial()!=other.polynomial():
                return 1
        return 0

    def __hash__(GFq self):
        """
        """
        if self.degree()>1:
            return hash((self.characteristic(),self.polynomial(),"givaro"))
        else:
            return hash((self.characteristic(),"givaro"))

    def _element_repr(GFq self, GFq_element e):
        """
        Wrapper for log,int, and poly representations.
        """
        if self.repr==0:
            return self._element_poly_repr(e)
        elif self.repr==1:
            return self._element_log_repr(e)
        else:
            return self._element_int_repr(e)

    def _element_log_repr(GFq self, GFq_element e):
        """
        Returns str(i) where base.gen()^i=self
        """
        return str(int(e.this))

    def _element_int_repr(GFq self, GFq_element e):
        """
	elements of this field will be written in the following
        manner: for e in ZZp[x] with e = a0 + a1x + a2x^2 + ..., e is
        represented as: 'n' where n = a0 + a1 * p + a2 * p^2 + ...

        """
        return str(int(e))

    def _element_poly_repr(GFq self, GFq_element e):
        """
        Returns a polynomial expression in base.gen() of self.
        """
        variable = self.variable_name()

        quo = self.log2int(e.this)
        b   = int(self.characteristic())

        ret = ""
        for i in range(self.degree()):
            coeff = quo%b
            if coeff != 0:
                if i>0:
                    if coeff==1:
                        coeff=""
                    else:
                        coeff=str(coeff)+"*"
                    if i>1:
                        ret = coeff + variable + "^" + str(i) + " + " + ret
                    else:
                        ret = coeff + variable + " + " + ret
                else:
                    ret = str(coeff) + " + " + ret
            quo = quo/b
        if ret == '':
            return "0"
        return ret[:-3]

    def axpy(GFq self,GFq_element a, GFq_element b, GFq_element c):
        """
        r <-  c + a * b mod p
        """
        #embed{ int GFq_element_axpy(void *field, int a, int b, int c)
        GivaroGfq::Element r;
        return ((GivaroGfq*)field)->axpy(r, a, b,c);
        #}embed

        cdef int r

        r = GFq_element_axpy(self.thisptr, a.this, b.this, c.this, )
        return make_GFq_element(self,r)

    def axmy(GFq self,GFq_element a, GFq_element b, GFq_element c):
        """
        r <- a * b - c mod p
        """
        #embed{ int GFq_element_axmy(void *field, int a, int b, int c)
        GivaroGfq::Element r;
        return ((GivaroGfq*)field)->axmy(r, a, b,c);
        #}embed

        cdef int r

        r = GFq_element_axmy(self.thisptr, a.this, b.this, c.this, )
        return make_GFq_element(self,r)

    def amxy(GFq self,GFq_element a, GFq_element b, GFq_element c):
        """
        r <- c - a * b mod p
        """
        #embed{ int GFq_element_amxy(void *field, int a, int b, int c)
        GivaroGfq::Element r;
        return ((GivaroGfq*)field)->amxy(r, a, b,c);
        #}embed

        cdef int r

        r = GFq_element_amxy(self.thisptr, a.this, b.this, c.this, )
        return make_GFq_element(self,r)

cdef class GFq_iterator:
    """
    Iterator implementation
    """
    cdef int iterator
    cdef GFq _parent

    def __init__(self,parent):
        self._parent = parent
        self.iterator = -1

    def __next__(self):
        """
        """

        self.iterator=self.iterator+1

        if self.iterator==self._parent.cardinality():
            self.iterator = -1
            raise StopIteration

        return make_GFq_element(self._parent,self.iterator)

    def __repr__(self):
        return "Iterator over %s"%self._parent

cdef GFq_copy(GFq orig):
    cdef GFq copy
    copy = GFq(orig.characteristic()**orig.degree())
    delete_GFq(copy.thisptr)
    #embed{ void *GFq_cpy(void *orig)
    return new GivaroGfq(*(GivaroGfq*)orig);
    #}embed
    copy.thisptr = GFq_cpy(orig.thisptr)
    return copy

cdef class GFq_element:
    cdef int this
    cdef GFq _parent
    cdef object __multiplicative_order

    def __init__(GFq_element self, GFq parent, value=None):
        """
        Initializes an element in parent. It's much better to use
        parent(<value>) or any specialized method of parent
        (one,zero,gen) instead.

        Alternatively you may provide a value which is directly
        assigned to this element. So the value must represent the
        log_g of the value you wish to assign.

        INPUT:
            parent -- base field
            value  -- assigns value to this element (default:None).

        OUTPUT:
            finite field element.
        """
        #embed{ void GFq_element_assign(void *field, int obj, int e)
        ((GivaroGfq*)field)->assign(obj,e);
        #}embed
        self._parent = parent
        self.this = GFq_element_init()
        if value!=None:
            GFq_element_assign(self._parent.thisptr, self.this, int(value))

    def __dealloc__(GFq_element self):
        pass

    def __repr__(GFq_element self):
        return self._parent._element_repr(self)

    def parent(self):
        """
        Returns parent finite field.
        """
        return self._parent

    def is_zero(GFq_element self):
        """
        Returns True if self == k(0).
        """
        #embed{ int GFq_is_zero(void *field, int e)
        return ((GivaroGfq*)field)->isZero(e);
        #}embed
        return bool(GFq_is_zero(self._parent.thisptr,self.this))

    def is_one(GFq_element self):
        """
        Returns True if self == k(1)
        """
        #embed{ int GFq_is_one(void *field, int e)
        return ((GivaroGfq*)field)->isOne(e);
        #}embed
        return bool(GFq_is_one(self._parent.thisptr,self.this))

    def is_unit(GFq_element self):
        """
        Returns True if self is an element of the prime subfield.
        """
        #embed{ int GFq_is_unit(void *field, int e)
        return ((GivaroGfq*)field)->isunit(e);
        #}embed
        return bool(GFq_is_unit(self._parent.thisptr,self.this))


    def __add__(self, other):
        #embed{ int GFq_element_add(void *field, int x, int y)
        GivaroGfq::Element r;
        return ((GivaroGfq*)field)->add(r,x,y);
        #}embed

        cdef int r

        if not isinstance(self,GFq_element):
            other,self = self,other

        if not isinstance(other,GFq_element):
            return bin_op(self,other,operator.add)
        else:
            r = GFq_element_add((<GFq_element>self)._parent.thisptr, (<GFq_element>self).this , (<GFq_element>other).this )
            return make_GFq_element((<GFq_element>self)._parent,r)

    def __mul__(self, other):
        #embed{ int GFq_element_mul(void *field, int x, int y)
        GivaroGfq::Element r;
        return ((GivaroGfq*)field)->mul(r, x, y);
        #}embed

        cdef int r

        if not isinstance(self,GFq_element):
            other,self = self,other

        if not isinstance(other,GFq_element):
            return bin_op(self,other,operator.mul)
        else:
            r = GFq_element_mul((<GFq_element>self)._parent.thisptr, (<GFq_element>self).this, (<GFq_element>other).this)
            return make_GFq_element((<GFq_element>self)._parent,r)

    def __div__(self, other):
        #embed{ int GFq_element_div(void *field, int x, int y)
        GivaroGfq::Element r;
        return ((GivaroGfq*)field)->div(r, x, y);
        #}embed

        cdef int r

        if not isinstance(self,GFq_element):
            other,self = self,other

        if not isinstance(other,GFq_element):
            return bin_op(self,other,operator.div)
        else:
            r = GFq_element_div((<GFq_element>self)._parent.thisptr, (<GFq_element>self).this, (<GFq_element>other).this)
            return make_GFq_element((<GFq_element>self)._parent,r)

    def __sub__(GFq_element self, other):
        #embed{ int GFq_element_sub(void *field, int x, int y)
        GivaroGfq::Element r;
        return ((GivaroGfq*)field)->sub(r, x, y);
        #}embed

        cdef int r

        if not isinstance(self,GFq_element):
            other,self = self,other

        if not isinstance(other,GFq_element):
            return bin_op(self,other,operator.sub)
        else:
            r = GFq_element_sub((<GFq_element>self)._parent.thisptr, (<GFq_element>self).this, (<GFq_element>other).this)
            return make_GFq_element((<GFq_element>self)._parent,r)

    def __neg__(GFq_element self):
        #embed{ int GFq_element_neg(void *field, int x)
        GivaroGfq::Element r;
        return ((GivaroGfq*)field)->neg(r, x);
        #}embed

        cdef int r

        r = GFq_element_neg(self._parent.thisptr, self.this)
        return make_GFq_element(self._parent,r)

    def __invert__(GFq_element self):
        #embed{ int GFq_element_inv(void *field, int x)
        GivaroGfq::Element r;
        return ((GivaroGfq*)field)->inv(r, x);
        #}embed

        cdef int r

        r = GFq_element_inv(self._parent.thisptr, self.this)
        return make_GFq_element(self._parent,r)


    def __pow__(GFq_element self, int exp, other):
        #There doesn't seem to exist a power function for GFq. So we
        #had to write one. It is pretty clumbsy (read: slow) right now

        #embed{ int GFq_element_pow(void *field, int e, int exp)
        exp = (exp%((GivaroGfq*)field)->one);

        if(exp<0) {
            e = ((GivaroGfq*)field)->invin(e);
            exp = -exp;
        }

        if(exp==0) {
            return ((GivaroGfq*)field)->one;
        } else {
            if(((GivaroGfq*)field)->isunit(e)) {
               int ret = ((GivaroGfq*)field)->one;
               for(int i=0; i< (exp%((GivaroGfq*)field)->characteristic()) ; i++) {
                   ((GivaroGfq*)field)->mulin(ret,e);
               };
               return ret;
            }
            return (exp*e)%((GivaroGfq*)field)->one;
        }
        #}embed

        cdef int r

        r = GFq_element_pow(self._parent.thisptr, self.this , exp )
        return make_GFq_element(self._parent,r)

    def __cmp__(self, other):
        return cmp(int(self),int(other))

    def __richcmp__(self, right, int op):
        if op == 0:  #<
            try:
                return bool(int(self) < int(right))
            except:
                return False
        if op == 2: #==
            try:
                return bool(int(self) == int(right))
            except:
                return False
        if op == 4: #>
            try:
                return bool(int(self) > int(right))
            except:
                return False
        if op == 1: #<=
            try:
                return bool(int(self) <= int(right))
            except:
                return False
        if op == 3: #!=
            try:
                return bool(int(self) != int(right))
            except:
                return True
        if op == 5: #>=
            try:
                return bool(int(self) >= int(right))
            except:
                return False

    def __int__(GFq_element self):
        """
        Returns self coerced to an int. The integer returned is
        equivalent to the representation of self and not to log_repr.
        """
        return self._parent.log2int(self.this)


    def log(GFq_element self):
        """
        Returns i where base.gen()^i=self
        """
        return int(self.this)

    def int_repr(GFq_element self):
        return self._parent._element_int_repr(self)

    def log_repr(GFq_element self):
        return self._parent._element_log_repr(self)

    def poly_repr(GFq_element self):
        return self._parent._element_poly_repr(self)

    def polynomial(GFq_element self):
        return self._parent.polynomial_ring()(self.poly_repr())

    def _latex_(GFq_element self):
        return self.polynomial()._latex_()

    def _sage_(GFq_element self, k):
        """
        Returns an element of k supposed to match this element.  No
        checks if k equals self.parent() are performed.

        INPUT:
            k -- SAGE finite field

        OUTPUT:
            k.gen()^(self.log_repr())

        """
        variable = k.gen()._pari_()

        quo = int(self)
        b   = self._parent.characteristic()

        ret = k._pari_one() - k._pari_one()
        i = 0
        while quo!=0:
            coeff = quo%b
            if coeff != 0:
                ret = coeff * variable ** i + ret
            quo = quo/b
            i = i+1
        return k(ret)

    def multiplicative_order(GFq_element self):
        """
        """
        # code copy'n'pasted from finite_field_element.py
        import sage.rings.arith
        from sage.ext.integer import Integer

        if self.__multiplicative_order!=None:
            return self.__multiplicative_order
        else:
            if self.is_zero():
                return ArithmeticError, "Multiplicative order of 0 not defined."
            n = self._parent.order() - 1
            order = 1
            for p, e in sage.rings.arith.factor(n):
                # Determine the power of p that divides the order.
                a = self**(n/(p**e))
                while a != self._parent.one():
                    order = order * p
                    a = a**p
            self.__multiplicative_order = order
            return order


    def __hash__(GFq_element self):
        return hash((self._parent,self.this))

cdef make_GFq_element(GFq parent, int x):
    """
    """
    cdef GFq_element y
    _sig_off
    y = GFq_element(parent)
    y.this = x
    return y
