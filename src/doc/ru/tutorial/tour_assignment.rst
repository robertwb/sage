Присваинвание,сравнивание и арифметика
======================================

С некоторыми исключениями Sage использует язык программирования Python,
поэтому многие книги, знакомящие с Python, помогут в изучении Sage.

Sage использует ``=`` для присваивания. ``==``, ``<=``, ``>=``, ``<`` и ``>``
используются для сравнения:

::

    sage: a = 5
    sage: a
    5
    sage: 2 == 2
    True
    sage: 2 == 3
    False
    sage: 2 < 3
    True
    sage: a == 5
    True

Sage поддерживает все базовые математические операции:

::

    sage: 2**3    #  ** means exponent
    8
    sage: 2^3     #  ^ is a synonym for ** (unlike in Python)
    8
    sage: 10 % 3  #  for integer arguments, % means mod, i.e., remainder
    1
    sage: 10/4
    5/2
    sage: 10//4   #  for integer arguments, // returns the integer quotient
    2
    sage: 4 * (10 // 4) + 10 % 4 == 10
    True
    sage: 3^2*4 + 2%5
    38

Вычисление выражения, как ``3^2*4 + 2%5``, зависит от порядка применения
операций, что описано в "таблице старшинства операций" в :ref:`section-precedence`.

Sage также поддерживает многие математические функции:

::

    sage: sqrt(3.4)
    1.84390889145858
    sage: sin(5.135)
    -0.912021158525540
    sage: sin(pi/3)
    1/2*sqrt(3)

Как показывает последний пример, некоторые математические выражения
возвращают 'точные' величины, но не численные приближения. Для того,
чтобы получить численное приближение, используйте функцию ``n`` или
метод ``n`` (оба имеют более длинные названия - ``numerical_approx``;
функция ``N`` - это то же самое, что и ``n``). Они принимают необязательные
аргументы ``prec``, который определяет количество битов точности, и ``digits``,
который определяет количество десятичных цифр точности. По умолчанию,
применяется 53 бита точности.

::

    sage: exp(2)
    e^2
    sage: n(exp(2))
    7.38905609893065
    sage: sqrt(pi).numerical_approx()
    1.77245385090552
    sage: sin(10).n(digits=5)
    -0.54402
    sage: N(sin(10),digits=10)
    -0.5440211109
    sage: numerical_approx(pi, prec=200)
    3.1415926535897932384626433832795028841971693993751058209749

Python имеет динамический контроль типов, так что значение, на
которое ссылается переменная, имеет тип, связанный с ним. Однако,
данная переменная может содержать значение любого типа из языка Python:

::

    sage: a = 5   # a is an integer
    sage: type(a)
    <type 'sage.rings.integer.Integer'>
    sage: a = 5/3  # now a is a rational number
    sage: type(a)
    <type 'sage.rings.rational.Rational'>
    sage: a = 'hello'  # now a is a string
    sage: type(a)
    <type 'str'>

Язык C, который имеет статический контроль типов, существенно отличается;
переменная, объявленная как целое число, может содержать только целое число.

Потенциальным источником путаницы в Python является тот факт, что
числовая константа, начинающаяся с 0, рассматривается как восьмеричное число,
т.е. число по основанию 8:

::

    sage: 011
    9
    sage: 8 + 1
    9
    sage: n = 011
    sage: n.str(8)   # string representation of n in base 8
    '11'
