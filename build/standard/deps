###############################################################################
# This file ($SAGE_ROOT/spkg/standard/deps) will be copied into
# $SAGE_ROOT/spkg/Makefile by $SAGE_ROOT/spkg/install
###############################################################################

INST = installed
# Let e.g. SAGE_ROOT/spkg/install pass options to sage-spkg, i.e. currently
# "-f", to force rebuilding dependent packages during an upgrade (#9896).
#
# When upgrading from a 4.x version of Sage, the script "sage-spkg" will be
# found in SAGE_ROOT/local/bin until the new sage_root repo is installed.
# After that, it will be found in SAGE_ROOT/spkg/bin
# (SAGE_ROOT/spkg/bin is added to the PATH in spkg/install).
# Therefore, do not put an explicit path for sage-spkg here.
SAGE_SPKG = sage-spkg $${SAGE_SPKG_OPTS}
PIPE = $(SAGE_ROOT)/spkg/pipestatus

# Tell make not to look for files with these names:
.PHONY: all all-sage base toolchain

# Make the 3 build phases: base, toolchain, all-sage
# During the toolchain build, we export SAGE_BUILD_TOOLCHAIN=yes
# such that packages can do different things when they are built
# as prerequisite of GCC.
all:
	$(MAKE) base
	env SAGE_BUILD_TOOLCHAIN=yes $(MAKE) toolchain
	$(MAKE) all-sage

# All targets except for the base packages
all-sage: \
     $(INST)/$(ATLAS) \
     $(INST)/$(BLAS) \
     $(INST)/$(BOEHM_GC) \
     $(INST)/$(BOOST_CROPPED) \
     $(INST)/$(CDDLIB) \
     $(INST)/$(CEPHES) \
     $(INST)/$(CLIQUER) \
     $(INST)/$(CONWAY) \
     $(INST)/$(CVXOPT) \
     $(INST)/$(CYTHON) \
     $(INST)/$(DOCUTILS) \
     $(INST)/$(ECL) \
     $(INST)/$(ECLIB) \
     $(INST)/$(ECM) \
     $(INST)/$(ELLIPTIC_CURVES) \
     $(INST)/$(EXTCODE) \
     $(INST)/$(FLINT) \
     $(INST)/$(FLINTQS) \
     $(INST)/$(FPLLL) \
     $(INST)/$(FREETYPE) \
     $(INST)/$(GENUS2REDUCTION) \
     $(INST)/$(GAP) \
     $(INST)/$(GD) \
     $(INST)/$(GDMODULE) \
     $(INST)/$(GFAN) \
     $(INST)/$(GIVARO) \
     $(INST)/$(GLPK) \
     $(INST)/$(GRAPHS) \
     $(INST)/$(GSL) \
     $(INST)/$(ICONV) \
     $(INST)/$(IML) \
     $(INST)/$(IPYTHON) \
     $(INST)/$(JINJA2) \
     $(INST)/$(JMOL) \
     $(INST)/$(LAPACK) \
     $(INST)/$(LCALC) \
     $(INST)/$(LRCALC) \
     $(INST)/$(M4RI) \
     $(INST)/$(M4RIE) \
     $(INST)/$(LIBPNG) \
     $(INST)/$(FFLASFFPACK) \
     $(INST)/$(LINBOX) \
     $(INST)/$(MATPLOTLIB) \
     $(INST)/$(MAXIMA) \
     $(INST)/$(MERCURIAL) \
     $(INST)/$(MPC) \
     $(INST)/$(MPFI) \
     $(INST)/$(MPFR) \
     $(INST)/$(MPIR) \
     $(INST)/$(MPMATH) \
     $(INST)/$(NETWORKX) \
     $(INST)/$(NTL) \
     $(INST)/$(NUMPY) \
     $(INST)/$(PALP) \
     $(INST)/$(PARI) \
     $(INST)/$(PEXPECT) \
     $(INST)/$(PIL) \
     $(INST)/$(POLYBORI) \
     $(INST)/$(POLYTOPES_DB) \
     $(INST)/$(PPL) \
     $(INST)/$(PYCRYPTO) \
     $(INST)/$(PYGMENTS) \
     $(INST)/$(PYNAC) \
     $(INST)/$(PYTHON) \
     $(INST)/$(RATPOINTS) \
     $(INST)/$(R) \
     $(INST)/$(RPY) \
     $(INST)/$(READLINE) \
     $(INST)/$(RUBIKS) \
     $(INST)/$(SAGE) \
     $(INST)/$(SAGE_SCRIPTS) \
     $(INST)/$(SAGE_ROOT_REPO) \
     $(INST)/$(SAGENB) \
     $(INST)/$(SAGETEX) \
     $(INST)/$(SCIPY) \
     $(INST)/$(SCONS) \
     $(INST)/$(SETUPTOOLS) \
     $(INST)/$(SINGULAR) \
     $(INST)/$(SPHINX) \
     $(INST)/$(SQLALCHEMY) \
     $(INST)/$(SQLITE) \
     $(INST)/$(SYMMETRICA) \
     $(INST)/$(SYMPOW) \
     $(INST)/$(SYMPY) \
     $(INST)/$(TACHYON) \
     $(INST)/$(TERMCAP) \
     $(INST)/$(ZLIB) \
     $(INST)/$(ZNPOLY) \
     $(INST)/$(ZODB)

# TOOLCHAIN consists of dependencies determined by spkg/install
toolchain: $(TOOLCHAIN)

# Everything needed to start up Sage using "./sage".  Of course, not
# every part of Sage will work.  It does not include Maxima for example.
SAGERUNTIME = $(INST)/$(SAGE_SCRIPTS) $(INST)/$(SAGE) $(INST)/$(SAGENB) \
              $(INST)/$(IPYTHON) $(INST)/$(GAP)

###############################################################################
# Building the base system
#
# This consists of packages which are required for the Sage build system
# but not for Sage itself.  Since nothing explicitly depends on these,
# an update of these packages will not trigger a rebuild of every other
# package during an upgrade, see #13415.
###############################################################################
base: $(INST)/$(PREREQ) $(INST)/$(BZIP2) $(INST)/$(PATCH)

$(INST)/$(PREREQ):
	$(PIPE) "base/$(PREREQ)-install 2>&1" "tee -a $(SAGE_LOGS)/$(PREREQ).log"

# If we are upgrading from a version 4.x of Sage, don't build bzip2.
# This is because the old sage-spkg script cannot install the new bzip2
# spkg (which is gzip compressed).  We continue using the old bzip2
# installation (which is version 1.0.5 since sage-3.3), which is fine.
$(INST)/$(BZIP2): $(INST)/$(PREREQ)
	+if [ -f "$(SAGE_ROOT)/spkg/bin/sage-spkg" ] ; then \
	    $(PIPE) "$(SAGE_SPKG) $(BZIP2) 2>&1" "tee -a $(SAGE_LOGS)/$(BZIP2).log"; \
	else \
	    touch "$@"; \
	fi

$(INST)/$(PATCH): $(INST)/$(BZIP2)
	+$(PIPE) "$(SAGE_SPKG) $(PATCH) 2>&1" "tee -a $(SAGE_LOGS)/$(PATCH).log"

###############################################################################
# Building normal packages
###############################################################################
$(INST)/$(ATLAS): $(INST)/$(LAPACK) $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(ATLAS) 2>&1" "tee -a $(SAGE_LOGS)/$(ATLAS).log"

$(INST)/$(BOEHM_GC):
	+$(PIPE) "$(SAGE_SPKG) $(BOEHM_GC) 2>&1" "tee -a $(SAGE_LOGS)/$(BOEHM_GC).log"

$(INST)/$(BOOST_CROPPED):
	+$(PIPE) "$(SAGE_SPKG) $(BOOST_CROPPED) 2>&1" "tee -a $(SAGE_LOGS)/$(BOOST_CROPPED).log"

$(INST)/$(CLIQUER):
	+$(PIPE) "$(SAGE_SPKG) $(CLIQUER) 2>&1" "tee -a $(SAGE_LOGS)/$(CLIQUER).log"

$(INST)/$(TERMCAP):
	+$(PIPE) "$(SAGE_SPKG) $(TERMCAP) 2>&1" "tee -a $(SAGE_LOGS)/$(TERMCAP).log"

$(INST)/$(READLINE): $(INST)/$(TERMCAP)
	+$(PIPE) "$(SAGE_SPKG) $(READLINE) 2>&1" "tee -a $(SAGE_LOGS)/$(READLINE).log"

$(INST)/$(ICONV):
	+$(PIPE) "$(SAGE_SPKG) $(ICONV) 2>&1" "tee -a $(SAGE_LOGS)/$(ICONV).log"

$(INST)/$(DOCUTILS): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(DOCUTILS) 2>&1" "tee -a $(SAGE_LOGS)/$(DOCUTILS).log"

# ELLIPTIC_CURVES depends on SAGE_ROOT_REPO because it needs SAGE_SHARE
# to be set in sage-env.
$(INST)/$(ELLIPTIC_CURVES): $(INST)/$(PYTHON) \
        $(INST)/$(SQLITE) $(INST)/$(SAGE_ROOT_REPO)
	+$(PIPE) "$(SAGE_SPKG) $(ELLIPTIC_CURVES) 2>&1" "tee -a $(SAGE_LOGS)/$(ELLIPTIC_CURVES).log"

# CONWAY depends on SAGE_ROOT_REPO because it needs SAGE_SHARE
# to be set in sage-env.
$(INST)/$(CONWAY): $(INST)/$(SAGE_ROOT_REPO)
	+$(PIPE) "$(SAGE_SPKG) $(CONWAY) 2>&1" "tee -a $(SAGE_LOGS)/$(CONWAY).log"

# GRAPHS depends on SAGE_ROOT_REPO because it needs SAGE_SHARE
# to be set in sage-env.
$(INST)/$(GRAPHS): $(INST)/$(SAGE_ROOT_REPO)
	+$(PIPE) "$(SAGE_SPKG) $(GRAPHS) 2>&1" "tee -a $(SAGE_LOGS)/$(GRAPHS).log"

$(INST)/$(GLPK): $(INST)/$(MPIR) $(INST)/$(ZLIB)
	+$(PIPE) "$(SAGE_SPKG) $(GLPK) 2>&1" "tee -a $(SAGE_LOGS)/$(GLPK).log"

# Python links against -lbz2.  Technically speaking, we should add
# BZIP2 as dependency here.  But we don't do that to avoid needless
# recompiles of Python when upgrading.  Since bzip2 is part of the
# "base" target, we are guaranteed anyway that some version of bzip2
# is present.
$(INST)/$(PYTHON): $(INST)/$(ZLIB) \
		   $(INST)/$(READLINE) $(INST)/$(SQLITE) $(INST)/$(LIBPNG)
	+$(PIPE) "$(SAGE_SPKG) $(PYTHON) 2>&1" "tee -a $(SAGE_LOGS)/$(PYTHON).log"

$(INST)/$(MPIR): $(INST)/$(ICONV)
	+$(PIPE) "$(SAGE_SPKG) $(MPIR) 2>&1" "tee -a $(SAGE_LOGS)/$(MPIR).log"

$(INST)/$(GSL): $(INST)/$(ATLAS)
	+$(PIPE) "$(SAGE_SPKG) $(GSL) 2>&1" "tee -a $(SAGE_LOGS)/$(GSL).log"

$(INST)/$(NTL): $(INST)/$(MPIR)
	+$(PIPE) "$(SAGE_SPKG) $(NTL) 2>&1" "tee -a $(SAGE_LOGS)/$(NTL).log"

$(INST)/$(FPLLL): $(INST)/$(MPIR) $(INST)/$(MPFR)
	+$(PIPE) "$(SAGE_SPKG) $(FPLLL) 2>&1" "tee -a $(SAGE_LOGS)/$(FPLLL).log"

$(INST)/$(PARI): $(INST)/$(READLINE) $(INST)/$(MPIR)
	+$(PIPE) "$(SAGE_SPKG) $(PARI) 2>&1" "tee -a $(SAGE_LOGS)/$(PARI).log"

$(INST)/$(POLYBORI): $(INST)/$(PYTHON) $(INST)/$(SCONS) \
		     $(INST)/$(BOOST_CROPPED) $(INST)/$(M4RI) \
		     $(INST)/$(GD)
	+$(PIPE) "$(SAGE_SPKG) $(POLYBORI) 2>&1" "tee -a $(SAGE_LOGS)/$(POLYBORI).log"

# POLYTOPES_DB depends on SAGE_ROOT_REPO because it needs SAGE_SHARE
# to be set in sage-env.
$(INST)/$(POLYTOPES_DB): $(INST)/$(SAGE_ROOT_REPO)
	+$(PIPE) "$(SAGE_SPKG) $(POLYTOPES_DB) 2>&1" "tee -a $(SAGE_LOGS)/$(POLYTOPES_DB).log"

# PPL depends on SAGE_ROOT_REPO because it *executes* C++ code at
# build time.  Therefore, it needs an up-to-date version of sage-env
# which adds $SAGE_LOCAL/lib64 to the LD_LIBRARY_PATH.
$(INST)/$(PPL): $(INST)/$(MPIR) $(INST)/$(SAGE_ROOT_REPO)
	+$(PIPE) "$(SAGE_SPKG) $(PPL) 2>&1" "tee -a $(SAGE_LOGS)/$(PPL).log"

$(INST)/$(MPC): $(INST)/$(MPIR) $(INST)/$(MPFR)
	+$(PIPE) "$(SAGE_SPKG) $(MPC) 2>&1" "tee -a $(SAGE_LOGS)/$(MPC).log"

$(INST)/$(MPFR): $(INST)/$(MPIR)
	+$(PIPE) "$(SAGE_SPKG) $(MPFR) 2>&1" "tee -a $(SAGE_LOGS)/$(MPFR).log"

$(INST)/$(MPFI): $(INST)/$(MPIR) $(INST)/$(MPFR)
	+$(PIPE) "$(SAGE_SPKG) $(MPFI) 2>&1" "tee -a $(SAGE_LOGS)/$(MPFI).log"

$(INST)/$(GIVARO): $(INST)/$(MPIR)
	+$(PIPE) "$(SAGE_SPKG) $(GIVARO) 2>&1" "tee -a $(SAGE_LOGS)/$(GIVARO).log"

$(INST)/$(FFLASFFPACK): $(INST)/$(MPIR) $(INST)/$(GIVARO) \
	$(INST)/$(GSL) $(INST)/$(ATLAS)
	+$(PIPE) "$(SAGE_SPKG) $(FFLASFFPACK) 2>&1" "tee -a $(SAGE_LOGS)/$(FFLASFFPACK).log"

$(INST)/$(LINBOX): $(INST)/$(MPIR) $(INST)/$(NTL) $(INST)/$(GIVARO) \
                   $(INST)/$(MPFR) $(INST)/$(FPLLL) $(INST)/$(IML) \
                   $(INST)/$(M4RI) $(INST)/$(M4RIE) $(INST)/$(FFLASFFPACK) \

	+$(PIPE) "$(SAGE_SPKG) $(LINBOX) 2>&1" "tee -a $(SAGE_LOGS)/$(LINBOX).log"

$(INST)/$(IML): $(INST)/$(MPIR) $(INST)/$(GSL) $(INST)/$(ATLAS)
	+$(PIPE) "$(SAGE_SPKG) $(IML) 2>&1" "tee -a $(SAGE_LOGS)/$(IML).log"

$(INST)/$(ECLIB): $(INST)/$(MPIR) $(INST)/$(PARI) $(INST)/$(NTL)
	+$(PIPE) "$(SAGE_SPKG) $(ECLIB) 2>&1" "tee -a $(SAGE_LOGS)/$(ECLIB).log"

$(INST)/$(GENUS2REDUCTION): $(INST)/$(PARI)
	+$(PIPE) "$(SAGE_SPKG) $(GENUS2REDUCTION) 2>&1" "tee -a $(SAGE_LOGS)/$(GENUS2REDUCTION).log"

$(INST)/$(PALP):
	+$(PIPE) "$(SAGE_SPKG) $(PALP) 2>&1" "tee -a $(SAGE_LOGS)/$(PALP).log"

$(INST)/$(LCALC): $(INST)/$(PARI) $(INST)/$(MPFR)
	+$(PIPE) "$(SAGE_SPKG) $(LCALC) 2>&1" "tee -a $(SAGE_LOGS)/$(LCALC).log"

$(INST)/$(LRCALC):
	+$(PIPE) "$(SAGE_SPKG) $(LRCALC) 2>&1" "tee -a $(SAGE_LOGS)/$(LRCALC).log"

$(INST)/$(PYNAC): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(PYNAC) 2>&1" "tee -a $(SAGE_LOGS)/$(PYNAC).log"

$(INST)/$(SYMPOW):
	+$(PIPE) "$(SAGE_SPKG) $(SYMPOW) 2>&1" "tee -a $(SAGE_LOGS)/$(SYMPOW).log"

$(INST)/$(SYMMETRICA):
	+$(PIPE) "$(SAGE_SPKG) $(SYMMETRICA) 2>&1" "tee -a $(SAGE_LOGS)/$(SYMMETRICA).log"

$(INST)/$(GAP): $(INST)/$(TERMCAP) $(INST)/$(READLINE) $(INST)/$(MPIR)
	+$(PIPE) "$(SAGE_SPKG) $(GAP) 2>&1" "tee -a $(SAGE_LOGS)/$(GAP).log"

$(INST)/$(IPYTHON): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(IPYTHON) 2>&1" "tee -a $(SAGE_LOGS)/$(IPYTHON).log"

$(INST)/$(PEXPECT): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(PEXPECT) 2>&1" "tee -a $(SAGE_LOGS)/$(PEXPECT).log"

$(INST)/$(GD): $(INST)/$(LIBPNG) $(INST)/$(FREETYPE) $(INST)/$(ICONV)
	+$(PIPE) "$(SAGE_SPKG) $(GD) 2>&1" "tee -a $(SAGE_LOGS)/$(GD).log"

$(INST)/$(GDMODULE): $(INST)/$(PYTHON) $(INST)/$(GD) $(INST)/$(ICONV)
	+$(PIPE) "$(SAGE_SPKG) $(GDMODULE) 2>&1" "tee -a $(SAGE_LOGS)/$(GDMODULE).log"

$(INST)/$(SCONS): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(SCONS) 2>&1" "tee -a $(SAGE_LOGS)/$(SCONS).log"

$(INST)/$(RUBIKS):
	+$(PIPE) "$(SAGE_SPKG) $(RUBIKS) 2>&1" "tee -a $(SAGE_LOGS)/$(RUBIKS).log"

$(INST)/$(SQLITE): $(INST)/$(READLINE)
	+$(PIPE) "$(SAGE_SPKG) $(SQLITE) 2>&1" "tee -a $(SAGE_LOGS)/$(SQLITE).log"

$(INST)/$(MERCURIAL): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(MERCURIAL) 2>&1" "tee -a $(SAGE_LOGS)/$(MERCURIAL).log"

# To build SageTeX, you just need Python, but to test (SAGE_CHECK=yes)
# SageTeX, you actually need to run sage, produce plots,...
$(INST)/$(SAGETEX): $(INST)/$(PYTHON) \
                    $(SAGERUNTIME) $(INST)/$(MAXIMA) $(INST)/$(SCIPY) \
                    $(INST)/$(MATPLOTLIB) $(INST)/$(PIL) $(INST)/$(TACHYON)
	+$(PIPE) "$(SAGE_SPKG) $(SAGETEX) 2>&1" "tee -a $(SAGE_LOGS)/$(SAGETEX).log"

$(INST)/$(SETUPTOOLS): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(SETUPTOOLS) 2>&1" "tee -a $(SAGE_LOGS)/$(SETUPTOOLS).log"

$(INST)/$(SINGULAR): $(INST)/$(MPIR) $(INST)/$(NTL) \
		     $(INST)/$(READLINE) $(INST)/$(MPFR)
	+$(PIPE) "$(SAGE_SPKG) $(SINGULAR) 2>&1" "tee -a $(SAGE_LOGS)/$(SINGULAR).log"

$(INST)/$(PYCRYPTO): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(PYCRYPTO) 2>&1" "tee -a $(SAGE_LOGS)/$(PYCRYPTO).log"

$(INST)/$(NETWORKX): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(NETWORKX) 2>&1" "tee -a $(SAGE_LOGS)/$(NETWORKX).log"

$(INST)/$(MPMATH): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(MPMATH) 2>&1" "tee -a $(SAGE_LOGS)/$(MPMATH).log"

$(INST)/$(ZLIB):
	+$(PIPE) "$(SAGE_SPKG) $(ZLIB) 2>&1" "tee -a $(SAGE_LOGS)/$(ZLIB).log"

$(INST)/$(JMOL): $(INST)/$(SAGENB)
	+$(PIPE) "$(SAGE_SPKG) $(JMOL) 2>&1" "tee -a $(SAGE_LOGS)/$(JMOL).log"

$(INST)/$(FREETYPE):
	+$(PIPE) "$(SAGE_SPKG) $(FREETYPE) 2>&1" "tee -a $(SAGE_LOGS)/$(FREETYPE).log"

$(INST)/$(LIBPNG): $(INST)/$(ZLIB)
	+$(PIPE) "$(SAGE_SPKG) $(LIBPNG) 2>&1" "tee -a $(SAGE_LOGS)/$(LIBPNG).log"

$(INST)/$(MATPLOTLIB): $(INST)/$(PYTHON) $(INST)/$(NUMPY) \
		       $(INST)/$(FREETYPE) $(INST)/$(LIBPNG) \
		       $(INST)/$(GDMODULE)
	+$(PIPE) "$(SAGE_SPKG) $(MATPLOTLIB) 2>&1" "tee -a $(SAGE_LOGS)/$(MATPLOTLIB).log"

$(INST)/$(CDDLIB): $(INST)/$(MPIR)
	+$(PIPE) "$(SAGE_SPKG) $(CDDLIB) 2>&1" "tee -a $(SAGE_LOGS)/$(CDDLIB).log"

# Gfan depends on SAGE_ROOT_REPO because it *executes* C++ code at
# build time.  Therefore, it needs an up-to-date version of sage-env
# which adds $SAGE_LOCAL/lib64 to the LD_LIBRARY_PATH.
$(INST)/$(GFAN): $(INST)/$(MPIR) $(INST)/$(CDDLIB) \
		$(INST)/$(SAGE_ROOT_REPO)
	+$(PIPE) "$(SAGE_SPKG) $(GFAN) 2>&1" "tee -a $(SAGE_LOGS)/$(GFAN).log"

$(INST)/$(TACHYON): $(INST)/$(LIBPNG)
	+$(PIPE) "$(SAGE_SPKG) $(TACHYON) 2>&1" "tee -a $(SAGE_LOGS)/$(TACHYON).log"

$(INST)/$(ECM): $(INST)/$(MPIR)
	+$(PIPE) "$(SAGE_SPKG) $(ECM) 2>&1" "tee -a $(SAGE_LOGS)/$(ECM).log"

$(INST)/$(RATPOINTS): $(INST)/$(MPIR)
	+$(PIPE) "$(SAGE_SPKG) $(RATPOINTS) 2>&1" "tee -a $(SAGE_LOGS)/$(RATPOINTS).log"

$(INST)/$(ECL): $(INST)/$(MPIR) $(INST)/$(READLINE) $(INST)/$(BOEHM_GC)
	+$(PIPE) "$(SAGE_SPKG) $(ECL) 2>&1" "tee -a $(SAGE_LOGS)/$(ECL).log"

$(INST)/$(MAXIMA): $(INST)/$(ECL)
	+$(PIPE) "$(SAGE_SPKG) $(MAXIMA) 2>&1" "tee -a $(SAGE_LOGS)/$(MAXIMA).log"

# R depends on SAGE_ROOT_REPO because it needs an up-to-date
# sage-env script which sets $OBJC on OS X.
$(INST)/$(R): $(INST)/$(ATLAS) $(INST)/$(ICONV) \
		 $(INST)/$(SAGE_ROOT_REPO) $(INST)/$(READLINE)
	+$(PIPE) "$(SAGE_SPKG) $(R) 2>&1" "tee -a $(SAGE_LOGS)/$(R).log"

$(INST)/$(RPY): $(INST)/$(PYTHON) $(INST)/$(R)
	+$(PIPE) "$(SAGE_SPKG) $(RPY) 2>&1" "tee -a $(SAGE_LOGS)/$(RPY).log"

$(INST)/$(SYMPY): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(SYMPY) 2>&1" "tee -a $(SAGE_LOGS)/$(SYMPY).log"

$(INST)/$(CYTHON): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(CYTHON) 2>&1" "tee -a $(SAGE_LOGS)/$(CYTHON).log"

$(INST)/$(FLINTQS): $(INST)/$(MPIR)
	+$(PIPE) "$(SAGE_SPKG) $(FLINTQS) 2>&1" "tee -a $(SAGE_LOGS)/$(FLINTQS).log"

$(INST)/$(FLINT): $(INST)/$(MPIR) $(INST)/$(NTL)
	+$(PIPE) "$(SAGE_SPKG) $(FLINT) 2>&1" "tee -a $(SAGE_LOGS)/$(FLINT).log"

# EXTCODE depends on SAGE_ROOT_REPO because it needs SAGE_EXTCODE
# to be set in sage-env.
$(INST)/$(EXTCODE): $(INST)/$(SAGE_ROOT_REPO)
	+$(PIPE) "$(SAGE_SPKG) $(EXTCODE) 2>&1" "tee -a $(SAGE_LOGS)/$(EXTCODE).log"

$(INST)/$(M4RI): $(INST)/$(LIBPNG)
	+$(PIPE) "$(SAGE_SPKG) $(M4RI) 2>&1" "tee -a $(SAGE_LOGS)/$(M4RI).log"

$(INST)/$(M4RIE): $(INST)/$(M4RI) $(INST)/$(GIVARO) $(INST)/$(NTL)
	+$(PIPE) "$(SAGE_SPKG) $(M4RIE) 2>&1" "tee -a $(SAGE_LOGS)/$(M4RIE).log"

# zn_poly really does depend on Python, despite this is far from obvious.
# The 'configure' script in zn_poly calls Python to make a 'makefile'.
$(INST)/$(ZNPOLY): $(INST)/$(MPIR) $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(ZNPOLY) 2>&1" "tee -a $(SAGE_LOGS)/$(ZNPOLY).log"

# the spkg-install file for the root repo uses many 'hg' commands, so
# build mercurial first.
$(INST)/$(SAGE_ROOT_REPO): $(INST)/$(MERCURIAL)
	+$(PIPE) "$(SAGE_SPKG) $(SAGE_ROOT_REPO) 2>&1" "tee -a $(SAGE_LOGS)/$(SAGE_ROOT_REPO).log"

$(INST)/$(SAGENB): $(INST)/$(PYTHON) $(INST)/$(SETUPTOOLS) $(INST)/$(PEXPECT) \
                   $(INST)/$(JINJA2) $(INST)/$(SPHINX) $(INST)/$(DOCUTILS)
	+$(PIPE) "$(SAGE_SPKG) $(SAGENB) 2>&1" "tee -a $(SAGE_LOGS)/$(SAGENB).log"

$(INST)/$(SQLALCHEMY): $(INST)/$(PYTHON) $(INST)/$(SETUPTOOLS)
	+$(PIPE) "$(SAGE_SPKG) $(SQLALCHEMY) 2>&1" "tee -a $(SAGE_LOGS)/$(SQLALCHEMY).log"

$(INST)/$(SPHINX): $(INST)/$(PYTHON) $(INST)/$(SETUPTOOLS) $(INST)/$(DOCUTILS) \
                   $(INST)/$(JINJA2) $(INST)/$(PYGMENTS)
	+$(PIPE) "$(SAGE_SPKG) $(SPHINX) 2>&1" "tee -a $(SAGE_LOGS)/$(SPHINX).log"

$(INST)/$(JINJA2): $(INST)/$(PYTHON) $(INST)/$(SETUPTOOLS) $(INST)/$(DOCUTILS) \

	+$(PIPE) "$(SAGE_SPKG) $(JINJA2) 2>&1" "tee -a $(SAGE_LOGS)/$(JINJA2).log"

$(INST)/$(PYGMENTS): $(INST)/$(PYTHON) $(INST)/$(SETUPTOOLS)
	+$(PIPE) "$(SAGE_SPKG) $(PYGMENTS) 2>&1" "tee -a $(SAGE_LOGS)/$(PYGMENTS).log"

$(INST)/$(ZODB): $(INST)/$(PYTHON) $(INST)/$(SETUPTOOLS)
	+$(PIPE) "$(SAGE_SPKG) $(ZODB) 2>&1" "tee -a $(SAGE_LOGS)/$(ZODB).log"

# List all *build-time* dependencies of the Sage library.  These are,
# on the one hand, programs needed for the build/install process of the
# Sage library (e.g. SAGE_SCRIPTS, SCONS, MERCURIAL, JINJA2), and on the
# other hand all dependencies for Cython files (e.g. PARI, NTL, MPIR).
$(INST)/$(SAGE): \
		 $(INST)/$(ATLAS) \
		 $(INST)/$(CEPHES) \
		 $(INST)/$(CLIQUER) \
		 $(INST)/$(CYTHON) \
		 $(INST)/$(ECL) \
		 $(INST)/$(ECLIB) \
		 $(INST)/$(ECM) \
		 $(INST)/$(FLINT) \
		 $(INST)/$(FPLLL) \
		 $(INST)/$(GD) \
		 $(INST)/$(GIVARO) \
		 $(INST)/$(GLPK) \
		 $(INST)/$(GSL) \
		 $(INST)/$(IML) \
		 $(INST)/$(JINJA2) \
		 $(INST)/$(LCALC) \
		 $(INST)/$(M4RI) \
		 $(INST)/$(M4RIE) \
		 $(INST)/$(LIBPNG) \
		 $(INST)/$(LINBOX) \
		 $(INST)/$(MERCURIAL) \
		 $(INST)/$(MPC) \
		 $(INST)/$(MPFI) \
		 $(INST)/$(MPFR) \
		 $(INST)/$(MPIR) \
		 $(INST)/$(NTL) \
		 $(INST)/$(NUMPY) \
		 $(INST)/$(PARI) \
		 $(INST)/$(POLYBORI) \
		 $(INST)/$(PPL) \
		 $(INST)/$(PYNAC) \
		 $(INST)/$(PYTHON) \
		 $(INST)/$(RATPOINTS) \
		 $(INST)/$(READLINE) \
		 $(INST)/$(SAGE_SCRIPTS) \
		 $(INST)/$(SCONS) \
		 $(INST)/$(SINGULAR) \
		 $(INST)/$(SYMMETRICA) \
		 $(INST)/$(ZNPOLY)
	+$(PIPE) "$(SAGE_SPKG) $(SAGE) 2>&1" "tee -a $(SAGE_LOGS)/$(SAGE).log"

# Because of ticket #11073 (remove the base repo), merged in sage-5.0,
# a version 5.x scripts repo does not work together with a version 4.x
# root repo.  When upgrading, we must therefore install the new root
# repo before the scripts repo.
$(INST)/$(SAGE_SCRIPTS): $(INST)/$(SAGE_ROOT_REPO)
	+$(PIPE) "$(SAGE_SPKG) $(SAGE_SCRIPTS) 2>&1" "tee -a $(SAGE_LOGS)/$(SAGE_SCRIPTS).log"

$(INST)/ccache: $(BASE) $(INST)/$(ZLIB)
	+$(PIPE) "$(SAGE_SPKG) ccache 2>&1" "tee -a $(SAGE_LOGS)/ccache.log"
	touch $(INST)/ccache

$(INST)/$(GCC): $(INST)/$(MPIR) $(INST)/$(MPFR) $(INST)/$(MPC) \
                $(INST)/$(ZLIB)
	+$(PIPE) "$(SAGE_SPKG) $(GCC) 2>&1" "tee -a $(SAGE_LOGS)/$(GCC).log"

$(INST)/$(PIL): $(INST)/$(PYTHON)
	+$(PIPE) "$(SAGE_SPKG) $(PIL) 2>&1" "tee -a $(SAGE_LOGS)/$(PIL).log"

# Lapack depends on SAGE_ROOT_REPO because it *executes* Fortran code at
# build time.  Therefore, it needs an up-to-date version of sage-env
# which adds $SAGE_LOCAL/lib64 to the LD_LIBRARY_PATH.
$(INST)/$(LAPACK): $(INST)/$(SAGE_ROOT_REPO)
	+$(PIPE) "$(SAGE_SPKG) $(LAPACK) 2>&1" "tee -a $(SAGE_LOGS)/$(LAPACK).log"

$(INST)/$(BLAS):
	+$(PIPE) "$(SAGE_SPKG) $(BLAS) 2>&1" "tee -a $(SAGE_LOGS)/$(BLAS).log"

$(INST)/$(NUMPY): $(INST)/$(PYTHON) \
		  $(INST)/$(LAPACK) $(INST)/$(BLAS) $(INST)/$(ATLAS)
	+$(PIPE) "$(SAGE_SPKG) $(NUMPY) 2>&1" "tee -a $(SAGE_LOGS)/$(NUMPY).log"

$(INST)/$(SCIPY): $(INST)/$(LAPACK) $(INST)/$(BLAS) $(INST)/$(NUMPY)
	+$(PIPE) "$(SAGE_SPKG) $(SCIPY) 2>&1" "tee -a $(SAGE_LOGS)/$(SCIPY).log"

# matplotlib is needed to test cvxopt (i.e., if SAGE_CHECK=yes). See #12742.
$(INST)/$(CVXOPT): \
		   $(INST)/$(LAPACK) $(INST)/$(BLAS) $(INST)/$(NUMPY) \
		   $(INST)/$(ATLAS) $(INST)/$(CEPHES) \
		   $(INST)/$(GSL) $(INST)/$(GLPK) $(INST)/$(MATPLOTLIB)
	+$(PIPE) "$(SAGE_SPKG) $(CVXOPT) 2>&1" "tee -a $(SAGE_LOGS)/$(CVXOPT).log"

$(INST)/$(CEPHES):
	+$(PIPE) "$(SAGE_SPKG) $(CEPHES) 2>&1" "tee -a $(SAGE_LOGS)/$(CEPHES).log"

###############################################################################

# setuptools forgets to update easy-install.pth during parallel
# builds, so we build the relevant packages serially.

$(INST)/$(SQLALCHEMY): $(INST)/$(ZODB)
$(INST)/$(PYGMENTS): $(INST)/$(SQLALCHEMY)
$(INST)/$(JINJA2): $(INST)/$(PYGMENTS)
$(INST)/$(SPHINX): $(INST)/$(JINJA2)
$(INST)/$(SAGENB): $(INST)/$(SPHINX)
