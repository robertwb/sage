--- src/src/kernel/integer/givintnumtheo.inl	2008-07-10 19:25:29.000000000 +0200
+++ patches/givintnumtheo.inl	2012-03-27 04:47:24.897732595 +0200
@@ -17,8 +17,8 @@
 // =================================================================== //
 template<class RandIter>
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::phi(Rep& res, const Rep& n) const {
-    if (isleq(n,1)) return res=n;
-    if (isleq(n,3)) return sub(res,n,this->one);
+    if (IntNumTheoDom<RandIter>::isleq(n,1)) return res=n;
+    if (IntNumTheoDom<RandIter>::isleq(n,3)) return IntNumTheoDom<RandIter>::sub(res,n,this->one);
     std::list<Rep> Lf;
     Father_t::set(Lf,n);
     //return phi (res,Lf,n);
@@ -29,11 +29,11 @@
 template<class RandIter>
 template< template<class, class> class Container, template<class> class Alloc>
  typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::phi(Rep& res, const Container<Rep, Alloc<Rep> >& Lf, const Rep& n) const {
-    if (isleq(n,1)) return res=n;
-    if (isleq(n,3)) return sub(res,n,this->one);
+    if (IntNumTheoDom<RandIter>::isleq(n,1)) return res=n;
+    if (IntNumTheoDom<RandIter>::isleq(n,3)) return IntNumTheoDom<RandIter>::sub(res,n,this->one);
     res = n; Rep t,m;
     for(typename Container<Rep, Alloc<Rep> >::const_iterator f=Lf.begin(); f!=Lf.end(); ++f) 
-        mul(res, divexact(t,res,*f), sub(m, *f, this->one));
+        IntNumTheoDom<RandIter>::mul(res, IntNumTheoDom<RandIter>::divexact(t,res,*f), IntNumTheoDom<RandIter>::sub(m, *f, this->one));
     return res;
 }
 
@@ -80,26 +80,26 @@
         // n must be in {2,4,p^m,2p^m} where p is an odd prime
         // else infinite loop
 
-    if (isleq(n,4)) return sub(A,n,this->one);
-    if (isZero(mod(A,n,4))) return A=this->zero;
+    if (IntNumTheoDom<RandIter>::isleq(n,4)) return IntNumTheoDom<RandIter>::sub(A,n,this->one);
+    if (isZero(IntNumTheoDom<RandIter>::mod(A,n,4))) return A=this->zero;
     Rep p,ismod2, q, no2, root; 
-    if (isZero(mod(ismod2,n,2))) divexact(no2,n,2); else no2=n;
+    if (isZero(IntNumTheoDom<RandIter>::mod(ismod2,n,2))) IntNumTheoDom<RandIter>::divexact(no2,n,2); else no2=n;
     p=no2;
     int k = 1; 
-    while (! isprime(p) ) {
+    while (! IntNumTheoDom<RandIter>::isprime(p) ) {
         sqrt(root, p);
-        while (mul(q,root,root) == p) {
+        while (IntNumTheoDom<RandIter>::mul(q,root,root) == p) {
             p = root;
             sqrt(root,p);
         }
-        if (! isprime(p) ) {
+        if (! IntNumTheoDom<RandIter>::isprime(p) ) {
             q=p;
-            while( p == q ) factor(p, q);
-            divin(q,p);
+            while( p == q ) IntNumTheoDom<RandIter>::factor(p, q);
+            IntNumTheoDom<RandIter>::divin(q,p);
             if (q < p) p = q;
         }
     }
-    if (isZero(ismod2)) mul(q,p,2); else q=p;
+    if (isZero(ismod2)) IntNumTheoDom<RandIter>::mul(q,p,2); else q=p;
     for(;q != n;++k,q*=p);
     Rep phin, tmp; 
     phi(phin,p);
@@ -134,21 +134,21 @@
     while (! found) {
        do {
             this->random(this->_g, A, p);
-            addin( modin(A,sub(tmp,p,7)) , 7);
+            IntNumTheoDom<RandIter>::addin( IntNumTheoDom<RandIter>::modin(A,IntNumTheoDom<RandIter>::sub(tmp,p,7)) , 7);
         } while ( ! isOne(gcd(tmp,A,p)) );
         found = ++runs;
         for(f=Lf.begin();(f!=Lf.end() && found);f++)
             found = (! isOne( this->powmod(tmp,A,*f,p)) );
     }
     if (k == 1) {
-        if (isZero(ismod2) && isZero(mod(ismod2, A, 2)))
+        if (isZero(ismod2) && isZero(IntNumTheoDom<RandIter>::mod(ismod2, A, 2)))
             return A+=p;
         else
             return A;
     } else {
         if (! is_prim_root(A,no2))
             A+=p;
-        if (isZero(ismod2) && isZero(mod(ismod2, A, 2)))
+        if (isZero(ismod2) && isZero(IntNumTheoDom<RandIter>::mod(ismod2, A, 2)))
             return A+=no2;
         else
             return A;
@@ -204,18 +204,18 @@
       Lq.pop_back(); 
        this->div(Temp, pmun, Q);
       do {
-          nonzerorandom(this->_g, alea, p);
-          modin(alea, p);
+          IntNumTheoDom<RandIter>::nonzerorandom(this->_g, alea, p);
+          IntNumTheoDom<RandIter>::modin(alea, p);
           this->powmod(essai, alea, Temp, p);
 //std::cerr << alea << " should be of order " << Q << " mod " << p << std::endl;
       } while (essai == 1);
 // looking for alea, of order Q with high probability      
       
-      mulin(primroot, essai);
+      IntNumTheoDom<RandIter>::mulin(primroot, essai);
 
 //  1-(1+2/(p-1))*(1-1/L^2)^log_B(Q)  < 1-(1+2^(-log_2(p)))*(1-1/L^2)^log_B(Q);
       essai = L;
-      mul(Temp, essai, L);
+      IntNumTheoDom<RandIter>::mul(Temp, essai, L);
       error = 1-1.0/(double)Temp;
       error = power(error, logp(Q,Temp) );
       error *= (1.0+1.0/((double)Q-1.0));
@@ -228,8 +228,8 @@
   for ( ; Lqi != Lq.end(); ++Lqi, ++ei) { 
        this->div(Temp, pmun, *Lqi);
       do {
-          nonzerorandom(this->_g, alea, p);
-          modin(alea, p);
+          IntNumTheoDom<RandIter>::nonzerorandom(this->_g, alea, p);
+          IntNumTheoDom<RandIter>::modin(alea, p);
           this->powmod(essai, alea, Temp, p);
 //std::cerr << alea << " should be of order at least " << *Lqi << "^" << *ei << "==" << power(*Lqi,*ei) << " mod " << p << std::endl;
       } while( essai == 1 ) ;
@@ -239,10 +239,10 @@
 //std::cerr << alea << " is of order at least " << (*Lqi) << "^" << (*ei) << "==" << power(*Lqi,*ei) << " mod " << p << std::endl;
           
       this->divin(Temp, power(*Lqi,*ei-1));
-      mulin(primroot, this->powmod(essai, alea, Temp, p));    
+      IntNumTheoDom<RandIter>::mulin(primroot, this->powmod(essai, alea, Temp, p));    
   }
 
-  modin(primroot, p);
+  IntNumTheoDom<RandIter>::modin(primroot, p);
   
   return primroot; 
 // return primroot with high probability
@@ -298,7 +298,7 @@
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::prim_root_of_prime(Rep& A, const Rep& n) const { 
     
     std::vector<Rep> Lf;
-    Rep phin; sub(phin,n,this->one);
+    Rep phin; IntNumTheoDom<RandIter>::sub(phin,n,this->one);
     Father_t::set(Lf,phin);
     return prim_root_of_prime(A, Lf, phin, n);
 }
@@ -330,14 +330,14 @@
 
     Rep primeorder;
     
-    for(bool exemp = true; exemp; nextprimein(prime) ) {
+    for(bool exemp = true; exemp; IntNumTheoDom<RandIter>::nextprimein(prime) ) {
         A = prime;
         primeorder = phin;
         for(typename Array::const_iterator f = Lf.begin(); f != Lf.end(); ++f) {
             this->powmod(tmp, prime, this->div(expo, primeorder, *f), n);
             if (isOne(tmp)) {
                 newLf.push_back(*f);
-                while (isZero(mod(tmp,expo,*f)) && isOne( this->powmod(tmp, prime, this->div(temp, expo, *f), n) ) ) { expo = temp; }
+                while (isZero(IntNumTheoDom<RandIter>::mod(tmp,expo,*f)) && isOne( this->powmod(tmp, prime, this->div(temp, expo, *f), n) ) ) { expo = temp; }
                 primeorder = expo;
 //                 std::cerr << "2 Order (Div): " << primeorder << std::endl;
             } else {
@@ -357,7 +357,7 @@
 //     std::cerr << "Root : " << A << std::endl;
 //     std::cerr << "Order : " << Aorder << std::endl;
     
-    for ( ; islt(Aorder,phin); nextprimein(prime) ) {
+    for ( ; IntNumTheoDom<RandIter>::islt(Aorder,phin); IntNumTheoDom<RandIter>::nextprimein(prime) ) {
         newLf.resize(0); oldLf.resize(0);
 
         for(typename Array::const_iterator f = Lf.begin(); f != Lf.end(); ++f) {
@@ -379,9 +379,9 @@
 
             this->powmod(tmp, prime, g, n);
 
-            modin( mulin(A, tmp), n );
+            IntNumTheoDom<RandIter>::modin( IntNumTheoDom<RandIter>::mulin(A, tmp), n );
 
-            mulin(Aorder, this->div(tmp, phin, g));
+            IntNumTheoDom<RandIter>::mulin(Aorder, this->div(tmp, phin, g));
 
             Lf = newLf;
         }
@@ -402,8 +402,8 @@
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::lowest_prim_root(Rep& A, const Rep& n) const {
         // n must be in {2,4,p^m,2p^m} where p is an odd prime
         // else returns zero
-    if (isleq(n,4)) return sub(A,n,this->one);
-    if (isZero(mod(A,n,4))) return A=this->zero;
+    if (IntNumTheoDom<RandIter>::isleq(n,4)) return IntNumTheoDom<RandIter>::sub(A,n,this->one);
+    if (isZero(IntNumTheoDom<RandIter>::mod(A,n,4))) return A=this->zero;
     Rep phin, tmp; 
     phi(phin,n);
     std::list<Rep> Lf;
@@ -412,15 +412,15 @@
     for(f=Lf.begin();f!=Lf.end();++f)
             this->div(*f,phin,*f);
     int found=0;
-    for(A = 2;(isleq(A,n) && (! found));addin(A,1)) {
+    for(A = 2;(IntNumTheoDom<RandIter>::isleq(A,n) && (! found));IntNumTheoDom<RandIter>::addin(A,1)) {
         if (isOne(gcd(tmp,A,n))) {
             found = 1;
             for(f=Lf.begin();(f!=Lf.end() && found);f++)
                 found = (! isOne( this->powmod(tmp,A,*f,n)) );
         }
     }
-    if (isleq(A,n))
-        return subin(A,1);
+    if (IntNumTheoDom<RandIter>::isleq(A,n))
+        return IntNumTheoDom<RandIter>::subin(A,1);
     else
         return A=this->zero; 
 }
@@ -434,7 +434,7 @@
     std::list<Rep> Lf;
     Father_t::set(Lf,phin);
     typename std::list<Rep>::iterator f=Lf.begin();
-    Rep A; mod(A,p,n);
+    Rep A; IntNumTheoDom<RandIter>::mod(A,p,n);
     if (isOne(gcd(tmp,A,n))) {
         found = true;
         for(;(f!=Lf.end() && found);f++) {
@@ -449,13 +449,13 @@
 bool IntNumTheoDom<RandIter>::isorder(const Rep& g, const Rep& p, const Rep& n) const {
         // returns 1 if p is of order g in Z/nZ
     Rep tmp;
-    return (isOne( this->powmod(tmp, p, g, n) ) && areEqual( g, order(tmp,p,n) ) );
+    return (isOne( this->powmod(tmp, p, g, n) ) && IntNumTheoDom<RandIter>::areEqual( g, order(tmp,p,n) ) );
 }
 
 template<class RandIter>
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::order(Rep& g, const Rep& p, const Rep& n) const {
         // returns 0 if failed
-    Rep A; mod(A,p,n);
+    Rep A; IntNumTheoDom<RandIter>::mod(A,p,n);
     if (isZero(A))
 	return g = this->zero;
     if (isOne(A))
@@ -474,7 +474,7 @@
                 break;
         if (noprimroot) {
             for(;f!=Lf.end();++f)
-                while (isZero(mod(tmp,g,*f)) && isOne(  this->powmod(tmp,A,  this->div(gg,g,*f),n) ) )
+                while (isZero(IntNumTheoDom<RandIter>::mod(tmp,g,*f)) && isOne(  this->powmod(tmp,A,  this->div(gg,g,*f),n) ) )
                     g = gg;
             return g;
         } else
@@ -492,12 +492,12 @@
 
 template<class RandIter>
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::prim_elem(Rep& A, const Rep& n) const {
-    if (isleq(n,4)) { 
+    if (IntNumTheoDom<RandIter>::isleq(n,4)) { 
         Rep tmp; 
         return this->sub(A,n,this->one); 
     }
     
-    if (areEqual(n,8)) return init(A,2);
+    if (IntNumTheoDom<RandIter>::areEqual(n,8)) return IntNumTheoDom<RandIter>::init(A,2);
     return prim_base(A, n);
 }
 
@@ -516,8 +516,8 @@
     typename std::vector<Rep>::iterator a = Ra.begin() ;
     for( ;p!=Lp.end();++p, ++e, ++pe, ++a) {
         dom_power( *pe, *p, *e, *this);
-        if (areEqual(*p,2))
-            init(*a, 3);
+        if (IntNumTheoDom<RandIter>::areEqual(*p,2))
+            IntNumTheoDom<RandIter>::init(*a, 3);
         else
             prim_root(*a, *pe);
     }
@@ -544,13 +544,13 @@
 template<class RandIter>
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::lambda_inv_primpow(Rep & z, const Rep& p, const unsigned long e) const {
         // Prerequisite : p prime.
-    if (areEqual(p, 2)) {
-        if (e<=2) return init(z,e);
-        if (e==3) return init(z,2);
+    if (IntNumTheoDom<RandIter>::areEqual(p, 2)) {
+        if (e<=2) return IntNumTheoDom<RandIter>::init(z,e);
+        if (e==3) return IntNumTheoDom<RandIter>::init(z,2);
         return dom_power(z, p, e-2, *this);
     } else {
         Rep tmp;
-        return mulin( dom_power(z, p, e-1, *this), sub(tmp, p, this->one) );
+        return IntNumTheoDom<RandIter>::mulin( dom_power(z, p, e-1, *this), IntNumTheoDom<RandIter>::sub(tmp, p, this->one) );
     }
 }
 
@@ -559,16 +559,16 @@
     
 template<class RandIter>
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::lambda_inv(Rep & z, const Rep& m) const {
-        if (areEqual(m,2)) return init(z,1);
-        if (areEqual(m,3) || areEqual(m,4) || areEqual(m,8) ) return init(z,2);
+        if (IntNumTheoDom<RandIter>::areEqual(m,2)) return IntNumTheoDom<RandIter>::init(z,1);
+        if (IntNumTheoDom<RandIter>::areEqual(m,3) || IntNumTheoDom<RandIter>::areEqual(m,4) || IntNumTheoDom<RandIter>::areEqual(m,8) ) return IntNumTheoDom<RandIter>::init(z,2);
         return lambda_base(z, m);
 }
 
 template<class RandIter>
 typename IntNumTheoDom<RandIter>::Rep& IntNumTheoDom<RandIter>::lambda(Rep & z, const Rep& m) const {
-        if (areEqual(m,2)) return init(z,1);
-        if (areEqual(m,3) || areEqual(m,4)) return init(z,2);
-        if (areEqual(m,8) ) return init(z,3);
+        if (IntNumTheoDom<RandIter>::areEqual(m,2)) return IntNumTheoDom<RandIter>::init(z,1);
+        if (IntNumTheoDom<RandIter>::areEqual(m,3) || IntNumTheoDom<RandIter>::areEqual(m,4)) return IntNumTheoDom<RandIter>::init(z,2);
+        if (IntNumTheoDom<RandIter>::areEqual(m,8) ) return IntNumTheoDom<RandIter>::init(z,3);
         return lambda_base(z, m);
 }
 
@@ -592,7 +592,7 @@
 //            Rep g;
 //            gcd(g, z, tmp);
 //            mulin(z, this->divin(tmp, g));
-	    lcmin(z,tmp);
+	    IntNumTheoDom<RandIter>::lcmin(z,tmp);
         }
         
         return z;
--- src/src/kernel/integer/givintrsa.inl	2008-04-21 16:01:56.000000000 +0200
+++ patches/givintrsa.inl	2012-03-27 03:43:34.037731848 +0200
@@ -195,14 +195,14 @@
         this->random(g,t,3); 
         this->random(g,s,3); 
     }
-    nextprimein( t );
-    nextprimein( s );
+    IntRSADom<RandIter>::nextprimein( t );
+    IntRSADom<RandIter>::nextprimein( s );
     
     
 
     r = t<<1;
     ++r;
-    while( ! isprime(r,4) ) {
+    while( ! IntRSADom<RandIter>::isprime(r,4) ) {
         r += t<<1;
     }
 
@@ -221,7 +221,7 @@
     r <<= 1;
     
     p = q+r;
-    while( ! isprime(p,4) ) {
+    while( ! IntRSADom<RandIter>::isprime(p,4) ) {
         p += r;
     }
 
@@ -246,21 +246,21 @@
     do  strong_prime(g, qsize, q); while (q == p);
     
 
-    Element phim; mul(phim, sub(d,p,IntFactorDom<RandIter>::one), sub(l,q,IntFactorDom<RandIter>::one));
-    mul(m, p, q);
+    Element phim; IntRSADom<RandIter>::mul(phim, IntRSADom<RandIter>::sub(d,p,IntFactorDom<RandIter>::one), IntRSADom<RandIter>::sub(l,q,IntFactorDom<RandIter>::one));
+    IntRSADom<RandIter>::mul(m, p, q);
 
     Element v, gd;
 
     if (_fast_impl) {
-        mod(k,SIMPLE_EXPONENT, phim);
+        IntRSADom<RandIter>::mod(k,SIMPLE_EXPONENT, phim);
         this->gcd(gd,u,v,k,phim);
     } else {
         do {
             this->random(g,k,phim);
         } while (this->gcd(gd,u,v,k,phim) != 1);
     }
-    modin(u,phim);
-    if ( islt(u,IntFactorDom<RandIter>::zero) ) addin(u,phim);
+    IntRSADom<RandIter>::modin(u,phim);
+    if ( IntRSADom<RandIter>::islt(u,IntFactorDom<RandIter>::zero) ) IntRSADom<RandIter>::addin(u,phim);
 }
 
 // =================================================================== //
@@ -270,10 +270,10 @@
 typename IntRSADom<RandIter>::Element& IntRSADom<RandIter>::point_break(Element& u) {
     if ( isZero(_u) ) {
         Element p,v,d, pm;
-        factor(p, _m);
-        mul(pm, sub(v,p,IntFactorDom<RandIter>::one), subin( this->div(d,_m,p), IntFactorDom<RandIter>::one ) );
+        IntRSADom<RandIter>::factor(p, _m);
+        IntRSADom<RandIter>::mul(pm, IntRSADom<RandIter>::sub(v,p,IntFactorDom<RandIter>::one), IntRSADom<RandIter>::subin( this->div(d,_m,p), IntFactorDom<RandIter>::one ) );
         this->gcd(d,_u,v,_k,pm);
-        if (islt(_u,IntFactorDom<RandIter>::zero)) addin(_u, pm);
+        if (IntRSADom<RandIter>::islt(_u,IntFactorDom<RandIter>::zero)) IntRSADom<RandIter>::addin(_u, pm);
     }
     return u = _u;
 }
--- src/src/library/poly1/givpoly1factor.inl	2008-02-26 23:11:36.000000000 +0100
+++ patches/givpoly1factor.inl	2012-03-27 15:03:08.837739790 +0200
@@ -24,7 +24,7 @@
     , Residu_t MOD) const {
 	typename Domain::Element one;
 	_domain.init(one, 1UL);
-    Degree dG;degree(dG,G);
+    Degree dG; this->degree(dG,G);
     if (dG == d)
         L.push_back(G);
     else {
@@ -32,7 +32,7 @@
         while (! splitted) {
             Rep tmp, G1;
             this->gcd(G1, G, this->random(_g, tmp, dG-1));
-            Degree dG1; degree(dG1,G1);
+            Degree dG1; this->degree(dG1,G1);
 // write(std::cerr << "SF rd: ", tmp) << std::endl;
 // write(std::cerr << "SF G1: ", G1) << std::endl;
             if ( dG1 != dG) {
@@ -44,8 +44,8 @@
                 Integer pp = (power(Integer(MOD), d.value()) - 1)/2;
 // std::cerr << "pp: " << pp << std::endl;
                 Rep tp, tp2, G2;
-                this->gcd(G2,G, sub(tp2, this->powmod(tp, tmp, pp, G) , one) );
-                Degree dG2; degree(dG2,G2);
+                this->gcd(G2,G, this->sub(tp2, this->powmod(tp, tmp, pp, G) , one) );
+                Degree dG2; this->degree(dG2,G2);
 // write(std::cerr << "SF t2: ", tp2) << std::endl;
 // write(std::cerr << "SF G2: ", G2) << std::endl;
                 if ( dG2 != dG) {
@@ -54,8 +54,8 @@
                         SplitFactor ( L, G2, d, MOD) ;
                     }
 // UNNECESSARY : ANYTHING FOUND BY G3 WOULD HAVE THE COFACTOR IN G2
-                     Rep G3; this->gcd(G3, G, add(tp2,tp,one) );
-                     Degree dG3; degree(dG3,G3);
+                     Rep G3; this->gcd(G3, G, this->add(tp2,tp,one) );
+                     Degree dG3; this->degree(dG3,G3);
 // write(std::cerr << "SF t3: ", tp2) << std::endl;
 // write(std::cerr << "SF G3: ", G3) << std::endl;
                      if (( dG3 != dG) && (dG3 > 0 )) {
@@ -133,21 +133,21 @@
 // write(std::cerr << "DD in: ", f) << std::endl;
     Rep W, D, P = f;
     Degree dP;
-    Rep Unit, G1; init(Unit, Degree(1), one);
+    Rep Unit, G1; this->init(Unit, Degree(1), one);
     W.copy(Unit);
-    degree(dP,P); Degree dPo = (dP/2);
+    this->degree(dP,P); Degree dPo = (dP/2);
     for(Degree dp = 1; dp <= dPo; ++dp) {
 // std::cerr << "DD degree: " << dp << std::endl;
         this->powmod(W, D.copy(W), MOD, P);
-        this->gcd (G1,sub(D,W,Unit), P) ;
-        Degree dG1; degree(dG1,G1);
+        this->gcd (G1,this->sub(D,W,Unit), P) ;
+        Degree dG1; this->degree(dG1,G1);
 // write(std::cerr << "DD found: ", G1) << ", of degree " << dG1 << std::endl;
         if ( dG1 > 0 ) {
             SplitFactor (L, G1, dp, MOD);
-            divin(P,G1);
+            this->divin(P,G1);
         }
     }
-    degree(dP,P);    
+    this->degree(dP,P);    
     if (dP > 0)
         L.push_back(P);
 // write(std::cerr << "DD: ", P) << std::endl;
@@ -165,10 +165,10 @@
 	       const Rep& P,
 	       Residu_t MOD)  const {
 // write(std::cerr << "CZ in: ", P) << std::endl;
-    Degree dp; degree(dp,P);
+    Degree dp; this->degree(dp,P);
     size_t nb=dp.value()+1; 
     Rep * g = new Rep[nb];
-    sqrfree(nb,g,P);
+    this->sqrfree(nb,g,P);
 // std::cerr << "CZ sqrfree: " << nb << std::endl;
     for(size_t i = 0; i<nb;++i) {
         size_t this_multiplicity = Lf.size();
@@ -200,17 +200,17 @@
         // Square free ?
    typename Domain::Element _one;
    _domain.init(_one,1UL); 
-   Rep W,D; this->gcd(W,diff(D,P),P);
+   Rep W,D; this->gcd(W,Poly1FactorDom<Domain,Tag, RandIter>::diff(D,P),P);
     Degree d, dP;
-    if (degree(d,W) > 0) return 0;
+    if (Poly1FactorDom<Domain,Tag, RandIter>::degree(d,W) > 0) return 0;
         // Distinct degree free ?
-    Rep Unit, G1; init(Unit, Degree(1), _one);
+    Rep Unit, G1; Poly1FactorDom<Domain,Tag, RandIter>::init(Unit, Degree(1), _one);
     W.copy(Unit);
-    degree(dP,P); Degree dPo = (dP/2);
+    Poly1FactorDom<Domain,Tag, RandIter>::degree(dP,P); Degree dPo = (dP/2);
     for(Degree dp = 1; dp <= dPo; ++dp) {
         this->powmod(W, D.copy(W), MOD, P);
-        this->gcd (G1, sub(D,W,Unit), P) ;
-        if ( degree(d,G1) > 0 ) return 0;
+        this->gcd (G1, Poly1FactorDom<Domain,Tag, RandIter>::sub(D,W,Unit), P) ;
+        if ( Poly1FactorDom<Domain,Tag, RandIter>::degree(d,G1) > 0 ) return 0;
     }
     return 1;
 }
--- src/src/library/poly1/givpoly1padic.h	2007-11-21 11:40:39.000000000 +0100
+++ patches/givpoly1padic.h	2012-03-27 05:11:31.197732877 +0200
@@ -106,11 +106,11 @@
             IntegerDom::divmod(iq, ir, E, q);
             radix(Q, iq, n-t);
             radix(P, ir, t);
-            Degree dp; degree(dp,P); ++dp;
+            Degree dp; this->degree(dp,P); ++dp;
             for(long i=t; dp<i; --i)
                 P.push_back(_domain.zero);
         P.insert(P.end(),Q.begin(),Q.end());
-        return setdegree(P);
+        return this->setdegree(P);
     } 
 
 
--- src/src/library/poly1/givpoly1proot.inl	2007-10-02 16:49:45.000000000 +0200
+++ patches/givpoly1proot.inl	2012-03-27 04:57:49.437732716 +0200
@@ -28,7 +28,7 @@
 
 template<class Domain, class Tag, class RandIter >
 inline typename Poly1FactorDom<Domain,Tag, RandIter>::Element& Poly1FactorDom<Domain,Tag, RandIter>::creux_random_irreducible (Element& R, Degree n) const {
-    init(R, n, _domain.one);
+    Poly1FactorDom<Domain,Tag, RandIter>::init(R, n, _domain.one);
     Residu_t MOD = _domain.residu();
 
         // Search for an irreducible BINOMIAL : X^n + a
@@ -97,9 +97,9 @@
 // ---------------------------------------------------------------
 template<class Domain, class Tag, class RandIter >
 inline typename Poly1FactorDom<Domain,Tag, RandIter>::Element& Poly1FactorDom<Domain,Tag, RandIter>::ixe_irreducible (Element& R, Degree n) const {
-    init(R, n, _domain.one);
+    Poly1FactorDom<Domain,Tag, RandIter>::init(R, n, _domain.one);
     Element IXE;
-    init(IXE,Degree(1),_domain.one);
+    Poly1FactorDom<Domain,Tag, RandIter>::init(IXE,Degree(1),_domain.one);
     Residu_t MOD = _domain.residu();
 
         // Search for an irreducible BINOMIAL : X^n + a
@@ -229,13 +229,13 @@
 template<class Domain, class Tag, class RandIter>
 bool Poly1FactorDom<Domain,Tag, RandIter>::is_prim_root( const Rep& P, const Rep& F)  const {
     bool isproot = 0;
-    Rep A, G; mod(A,P,F);
+    Rep A, G; Poly1FactorDom<Domain,Tag, RandIter>::mod(A,P,F);
     Degree d;
-    if ( degree(d, this->gcd(G,A,F)) == 0) {
+    if ( Poly1FactorDom<Domain,Tag, RandIter>::degree(d, this->gcd(G,A,F)) == 0) {
         Residu_t MOD = _domain.residu();
         IntFactorDom<> FD;
         IntFactorDom<>::Element IMOD( MOD ), q, qp;
-        degree(d,F);
+        Poly1FactorDom<Domain,Tag, RandIter>::degree(d,F);
 //         FD.pow(q ,IMOD, d.value());
 //         FD.sub(qp, q, FD.one);
         FD.subin( FD.pow(qp ,IMOD, d.value()) , FD.one);
@@ -286,14 +286,14 @@
 
 template<class Domain, class Tag, class RandIter >
 inline typename Poly1FactorDom<Domain,Tag, RandIter>::Rep& Poly1FactorDom<Domain,Tag, RandIter>::give_prim_root(Rep& R, const Rep& F)  const {
-    Degree n; degree(n,F);
+    Degree n; Poly1FactorDom<Domain,Tag, RandIter>::degree(n,F);
     Residu_t MOD = _domain.residu();
 //    this->write(std::cout << "Give Pr: ", F) << std::endl;
     
     
         // Search for a primitive BINOMIAL : X^i + a
     for(Degree di=1;di<n;++di) {
-        init(R, di, _domain.one);
+        Poly1FactorDom<Domain,Tag, RandIter>::init(R, di, _domain.one);
 //         for(Residu_t a=MOD; a--; ) {
         for(Residu_t a=0; a<MOD;++a ) {
             _domain.assign(R[0],a);
@@ -303,7 +303,7 @@
     }
         // Search for a primitive TRINOMIAL : X^i + b*X^j + a
     for(Degree di=2;di<n;++di) {
-        init(R, di, _domain.one);
+        Poly1FactorDom<Domain,Tag, RandIter>::init(R, di, _domain.one);
         for(Degree dj=1;dj<di;++dj)
 //             for(Residu_t b=MOD; b--;) {
             for(Residu_t b=0; b<MOD;++b) {
