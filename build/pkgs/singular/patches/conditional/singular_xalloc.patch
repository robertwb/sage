# HG changeset patch
# User Simon King <simon.king@uni-jena.de>
# Date 1354189511 -3600
# Node ID 16081b90915b00b49c62089d51dc2f30e5b4327f
# Parent  6f7df27014a3c42decbda471871aae6012bc7d6d
See Sage trac #13731: Create a Singular spkg using xalloc instead of omalloc.

diff --git a/kernel/kutil.cc b/kernel/kutil.cc
--- a/kernel/kutil.cc
+++ b/kernel/kutil.cc
@@ -666,7 +666,9 @@
           return dReportError("pNext(%c[%d].max) != NULL", TN, i);
 
         pFalseReturn(p_CheckPolyRing(T->max, tailRing));
+#ifndef X_OMALLOC
         omCheckBinAddrSize(T->max, (tailRing->PolyBin->sizeW)*SIZEOF_LONG);
+#endif
 #if KDEBUG > 0
         if (! sloppy_max)
         {
diff --git a/kernel/pDebug.cc b/kernel/pDebug.cc
--- a/kernel/pDebug.cc
+++ b/kernel/pDebug.cc
@@ -72,6 +72,7 @@
 {
   if (p != NULL)
   {
+#ifndef X_OMALLOC
     #if (OM_TRACK > 0) && defined(OM_TRACK_CUSTOM)
     void* custom = omGetCustomOfAddr(p);
     if (custom != NULL)
@@ -92,6 +93,7 @@
       return TRUE;
     }
     return FALSE;
+#endif
   }
   return TRUE;
 }
@@ -211,8 +213,10 @@
 
   #ifndef OM_NDEBUG
   // check addr with level+1 so as to check bin/page of addr
+#ifndef X_OMALLOC
   pPolyAssumeReturnMsg(omTestBinAddrSize(p, (r->PolyBin->sizeW)*SIZEOF_LONG, level+1)
                         == omError_NoError, "memory error",p,r);
+#endif
   #endif
 
   pFalseReturn(p_CheckRing(r));
@@ -231,8 +235,10 @@
     pFalseReturn(p_LmCheckIsFromRing(p, r));
     #ifndef OM_NDEBUG
     // omAddr check
+#ifndef X_OMALLOC
     pPolyAssumeReturnMsg(omTestBinAddrSize(p, (r->PolyBin->sizeW)*SIZEOF_LONG, 1)
                      == omError_NoError, "memory error",p,r);
+#endif
     #endif
     // number/coef check
     pPolyAssumeReturnMsg(p->coef != NULL || (n_GetChar(r) >= 2), "NULL coef",p,r);
diff --git a/kernel/pInline1.h b/kernel/pInline1.h
--- a/kernel/pInline1.h
+++ b/kernel/pInline1.h
@@ -94,7 +94,9 @@
 PINLINE1 poly p_Init(const ring r, omBin bin)
 {
   p_CheckRing1(r);
+#ifndef X_OMALLOC
   pAssume1(bin != NULL && r->PolyBin->sizeW == bin->sizeW);
+#endif
   poly p;
   omTypeAlloc0Bin(poly, p, bin);
   p_MemAdd_NegWeightAdjust(p, r);
@@ -177,7 +179,9 @@
 PINLINE1 poly p_LmShallowCopyDelete(poly p, const ring r, omBin bin)
 {
   p_LmCheckPolyRing1(p, r);
+#ifndef X_OMALLOC
   pAssume1(bin->sizeW == r->PolyBin->sizeW);
+#endif
   poly new_p = p_New(r);
   p_MemCopy_LengthGeneral(new_p->exp, p->exp, r->ExpL_Size);
   pSetCoeff0(new_p, pGetCoeff(p));
diff --git a/kernel/pInline2.h b/kernel/pInline2.h
--- a/kernel/pInline2.h
+++ b/kernel/pInline2.h
@@ -296,7 +296,9 @@
 PINLINE2 poly p_New(ring r, omBin bin)
 {
   p_CheckRing2(r);
+#ifndef X_OMALLOC
   pAssume2(bin != NULL && r->PolyBin->sizeW == bin->sizeW);
+#endif
   poly p;
   omTypeAllocBin(poly, p, bin);
   p_SetRingOfLm(p, r);
@@ -478,7 +480,9 @@
 PINLINE2 poly p_ShallowCopyDelete(poly p, const ring r, omBin bin)
 {
   p_LmCheckPolyRing2(p, r);
+#ifndef X_OMALLOC
   pAssume2(r->PolyBin->sizeW == bin->sizeW);
+#endif
   return r->p_Procs->p_ShallowCopyDelete(p, r, bin);
 }
 
diff --git a/kernel/pShallowCopyDelete.cc b/kernel/pShallowCopyDelete.cc
--- a/kernel/pShallowCopyDelete.cc
+++ b/kernel/pShallowCopyDelete.cc
@@ -18,7 +18,9 @@
   p_CheckPolyRing(s_p, s_r);
   p_CheckRing(d_r);
   assume(d_bin != NULL);
+#ifndef X_OMALLOC
   assume(d_bin == d_r->PolyBin || d_bin->sizeW == d_r->PolyBin->sizeW);
+#endif
   assume(s_r->N == d_r->N);
 
   spolyrec dp;
diff --git a/omalloc/Makefile b/omalloc/Makefile
new file mode 100644
--- /dev/null
+++ b/omalloc/Makefile
@@ -0,0 +1,37 @@
+#################################################################
+###
+### Makefile for xalloc
+###
+#################################################################
+
+
+# normal C source files
+CSOURCES=omFindExec.c
+
+HEADERS=omalloc.h
+
+OBJS := $(CSOURCES:.c=.o)
+
+.cc.o:	
+	${CXX} ${CXXFLAGS} ${CXXTEMPLFLAGS} ${CPPFLAGS} ${DEFS} -c $<
+.c.o:
+	${CC} ${CFLAGS} ${CPPFLAGS} ${DEFS} -c $<
+
+all:	libomalloc.a
+
+libomalloc.a: $(OBJS)
+	rm -f $@
+	$(AR) cr $@ $(OBJS)
+	$(RANLIB) $@
+
+install: libomalloc.a
+	install omalloc.h $(SAGE_LOCAL)/include/
+	install mylimits.h $(SAGE_LOCAL)/include/
+	install libomalloc.a $(SAGE_LOCAL)/lib/
+
+install-nolns: install
+
+install-libsingular: install
+
+clean:
+	rm *.o *.a
diff --git a/omalloc/mylimits.h b/omalloc/mylimits.h
new file mode 100644
--- /dev/null
+++ b/omalloc/mylimits.h
@@ -0,0 +1,15 @@
+/* -*-c++-*- */
+/*******************************************************************
+ *  File:    mylimits.h
+ *  Purpose: limits.h configuration for omalloc
+ *  Author:  hannes (Hans Schoenemann)
+ *  Created: 03/01
+ *  Version: $Id: mylimits.h 12231 2009-11-02 10:12:22Z hannes $
+ *******************************************************************/
+/* on IRIX-6 machines, the values in <limits.h>
+* do not reflect the code generated by gcc -
+* we would need our own definitions, but we don't
+* have them in the Sage spkg...
+*/
+
+#include <limits.h>
diff --git a/omalloc/omFindExec.c b/omalloc/omFindExec.c
new file mode 100755
--- /dev/null
+++ b/omalloc/omFindExec.c
@@ -0,0 +1,226 @@
+/*******************************************************************
+ *  File:    omFindExec.c
+ *  Purpose: routine which determines absolute pathname of executable
+ *  Author:  obachman (Olaf Bachmann)
+ *  Created: 11/99
+ *  Version: $Id: omFindExec.c,v 1.11 2008/02/03 20:03:14 wienand Exp $
+ *******************************************************************/
+
+#include <unistd.h> /* always defiend */
+#include <stdlib.h>
+#include <string.h>
+#include "omalloc.h"
+
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 1024
+#endif
+#define HAVE_GETCWD
+
+/* ABSOLUTE_FILENAME_P (fname): True if fname is an absolute filename */
+#define ABSOLUTE_FILENAME_P(fname)        (fname[0] == '/')
+
+/* Return the absolute name of the program named NAME.  This function
+   searches the directories in the PATH environment variable if PROG
+   has no directory components. */
+static char * omFindExec_link (const char *name, char* executable)
+{
+  char *search;
+  char *p;
+  char tbuf[MAXPATHLEN];
+
+  if (ABSOLUTE_FILENAME_P(name))
+  {
+      /* If we can execute the named file then return it. */
+      if (! access (name, X_OK))
+      {
+        strcpy(executable, name);
+#ifdef __CYGWIN__
+        strcat(executable, ".exe");
+#endif
+        return executable;
+      }
+  }
+  else
+  {
+    if (((name[0] == '.') && (name[1] == '/')) ||
+        ((name[0] == '.') && (name[1] == '.') && (name[2] == '/')) ||
+        strchr(name, '/') != NULL)
+    {
+
+#ifdef HAVE_GETCWD
+      getcwd (tbuf, MAXPATHLEN);
+#else
+# ifdef HAVE_GETWD
+      getwd (tbuf);
+# endif
+#endif
+      strcat (tbuf, "/");
+      strcat (tbuf, name);
+      if (! access(tbuf, X_OK))
+      {
+        strcpy(executable, tbuf);
+#ifdef __CYGWIN__
+        strcat(executable, ".exe");
+#endif
+        return executable;
+      }
+    }
+
+
+    search = getenv("PATH");
+    p = search;
+
+    if (p != NULL)
+    {
+      while (1)
+      {
+        char *next;
+        next = tbuf;
+
+        /* Copy directory name into [tbuf]. */
+        /* This is somewhat tricky: empty names mean cwd, w.r.t. some
+           shell spec */
+        while (*p && *p != ':')
+          *next ++ = *p ++;
+        *next = '\0';
+
+        if ((tbuf[0] == '.' && tbuf[1] == '\0') || tbuf[0] == '\0') {
+#ifdef HAVE_GETCWD
+          getcwd (tbuf, MAXPATHLEN);
+#else
+# ifdef HAVE_GETWD
+          getwd (tbuf);
+# endif
+#endif
+        }
+
+        if (tbuf[strlen(tbuf)-1] != '/') strcat(tbuf, "/");
+        strcat (tbuf, name);
+
+        /* If we can execute the named file, then return it. */
+        if (! access (tbuf, X_OK))
+        {
+          strcpy(executable, tbuf);
+#ifdef __CYGWIN__
+          strcat(executable, ".exe");
+#endif
+          return executable;
+        }
+
+        if (*p != '\0')
+        {
+          p ++;
+        }
+        else
+        {
+          break;
+        }
+      }
+    }
+  }
+  return NULL;
+}
+
+/* similar to readlink, but dont' mess up absolute pathnames */
+static int my_readlink(const char* name, char* buf, size_t bufsize)
+{
+  char buf2[MAXPATHLEN];
+  int ret;
+
+  if ((ret = readlink(name, buf2, bufsize)) > 0)
+  {
+    buf2[ret] = 0;
+    if (*name == '/' && *buf2 != '/')
+    {
+      char* last = strrchr(name, '/');
+      int i = 0;
+      while (&(name[i]) != last)
+      {
+        buf[i] = name[i];
+        i++;
+      }
+      buf[i] = '/';
+      i++;
+      strcpy(&(buf[i]), buf2);
+      return i + ret;
+    }
+    else
+    {
+      strcpy(buf, buf2);
+    }
+  }
+  return ret;
+}
+
+#define MAX_LINK_LEVEL 10
+/* similar to readlink (cf. man readlink), except that symbolic links are
+   followed up to MAX_LINK_LEVEL
+*/
+static int full_readlink(const char* name, char* buf, size_t bufsize)
+{
+  int ret;
+
+  if ((ret=my_readlink(name, buf, bufsize)) > 0)
+  {
+    char buf2[MAXPATHLEN];
+    int ret2, i = 0;
+
+    do
+    {
+      buf[ret] = '\0';
+      if ((ret2 = my_readlink(buf, buf2, MAXPATHLEN)) > 0)
+      {
+        i++;
+        buf2[ret2] = '\0';
+        strcpy(buf, buf2);
+        ret = ret2;
+      }
+      else
+      {
+        return ret;
+      }
+    }
+    while (i<MAX_LINK_LEVEL);
+  }
+  return -1;
+}
+
+
+char * omFindExec (const char *name, char* exec)
+{
+  char * link = omFindExec_link(name, exec);
+  char buf[MAXPATHLEN];
+  int ret;
+
+  if (link == NULL && (ret=full_readlink(name, buf, MAXPATHLEN)) > 0)
+  {
+    buf[ret] ='\0';
+    link = omFindExec_link(buf, exec);
+  }
+  if (link != NULL && (ret=full_readlink(link, buf, MAXPATHLEN)) > 0)
+  {
+    char *p = strrchr(link, '/');
+
+
+    if(p!=NULL) *(p+1)='\0';
+    buf[ret]='\0';
+
+    if (buf[0] != '/')
+    {
+      strcpy(exec, link);
+      strcat(exec, buf);
+    }
+    else
+    {
+      strcpy(exec, buf);
+    }
+
+    return exec;
+  }
+  return link;
+}
+
+int om_sing_opt_show_mem; /* dummy */
+struct omInfo_s om_Info; /* dummy */
+struct omOpts_s om_Opts; /* dummy */
+
diff --git a/omalloc/omalloc.h b/omalloc/omalloc.h
new file mode 100644
--- /dev/null
+++ b/omalloc/omalloc.h
@@ -0,0 +1,223 @@
+#ifndef XMEMORY_H
+#define XMEMORY_H
+/****************************************
+*  Computer Algebra System SINGULAR     *
+****************************************/
+/* $Id: mmemory.h,v 1.9 1998/06/02 15:29:58 Singular Exp $ */
+/*
+* ABSTRACT
+*/
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//struct omBin_s;
+//typedef struct omBin_s      omBin_t;
+//typedef omBin_t*            omBin;
+//
+//struct omBin_s
+//{
+// /*  omBinPage     current_page;    page of current freelist */
+// /*  omBinPage     last_page;       pointer to last page of freelist */
+//  omBin         next;           /* sticky bins of the same size */
+//  size_t        sizeW;          /* size in words */
+//  long          max_blocks;     /* if > 0   # blocks in one page,
+//                                   if < 0   # pages for one block */
+//  unsigned long sticky;         /* sticky tag */
+//};
+
+typedef size_t omBin;
+
+struct omInfo_s;
+typedef struct omInfo_s omInfo_t;
+struct omInfo_s
+{
+  long MaxBytesSystem;      /* set in omUpdateInfo(), is more accurate with malloc support   */
+  long CurrentBytesSystem;  /* set in omUpdateInfo(), is more accurate with malloc support */
+  long MaxBytesSbrk;        /* always up-to-date, not very accurate, needs omInintInfo() */
+  long CurrentBytesSbrk;    /* set in omUpdateInfo(), needs omInintInfo() */
+  long MaxBytesMmap;        /* set in omUpdateInfo(), not very accurate */
+  long CurrentBytesMmap;    /* set in omUpdateInfo(), not very accurate */
+  long UsedBytes;           /* set in omUpdateInfo() */
+  long AvailBytes;          /* set in omUpdateInfo() */
+  long UsedBytesMalloc;     /* set in omUpdateInfo(), needs malloc support */
+  long AvailBytesMalloc;    /* set in omUpdateInfo(), needs malloc support */
+  long MaxBytesFromMalloc;      /* always kept up-to-date */
+  long CurrentBytesFromMalloc;  /* always kept up-to-date */
+  long MaxBytesFromValloc;      /* always kept up-to-date */
+  long CurrentBytesFromValloc;  /* always kept up-to-date */
+  long UsedBytesFromValloc; /* set in omUpdateInfo()  */
+  long AvailBytesFromValloc;/* set in omUpdateInfo()  */
+  long MaxPages;            /* always kept up-to-date */
+  long UsedPages;           /* always kept up-to-date */
+  long AvailPages;          /* always kept up-to-date */
+  long MaxRegionsAlloc;     /* always kept up-to-date */
+  long CurrentRegionsAlloc; /* always kept up-to-date */
+};
+
+extern struct omInfo_s om_Info;
+
+struct omOpts_s;
+extern struct omOpts_s
+{
+  int MinTrack;
+  int MinCheck;
+  int MaxTrack;
+  int MaxCheck;
+  int Keep;
+  int HowToReportErrors;
+  int MarkAsStatic;
+  unsigned int PagesPerRegion;
+  void (*OutOfMemoryFunc)();
+  void (*MemoryLowFunc)();
+  void (*ErrorHook)();
+} om_Opts;
+
+typedef struct omOpts_s omOpts_t;
+
+extern int om_sing_opt_show_mem;
+
+static inline void * omAlloc(size_t s)
+{ if (s!=0) {long *d=(long*)malloc(s+sizeof(long)); *d=s;d++;return d; }
+  else return NULL;
+}
+static inline void * omAlloc0(size_t s)
+{ void *d=omAlloc(s);memset(d,0,s); return d; }
+
+static inline void *omRealloc(void *d, size_t ns)
+{ if (d==NULL) return omAlloc(ns);
+  else 
+  {
+    long *dd=(long*)d; dd--; dd=(long*)realloc(dd,ns+sizeof(long)); 
+    *dd=ns+sizeof(long);dd++; return dd;
+  }
+}
+static inline void *omReallocSize(void *d, size_t os, size_t ns)
+{ if (d==NULL) return omAlloc(ns);
+  else 
+  {
+    long *dd=(long*)d; dd--; dd=(long*)realloc(dd,ns+sizeof(long)); 
+    *dd=ns+sizeof(long);dd++; return dd;
+  }
+}
+static inline long omSizeOfAddr(void *d)
+{ long *dd=(long*)d; dd--; return *dd;}
+
+static inline void omFree(void *d)
+{ if (d!=NULL) { long *dd=(long*)d; dd--; free(dd);}}
+
+static inline void *omRealloc0(void *d, size_t ns)
+{
+  void *n=omAlloc0(ns);
+  if (d!=NULL)
+  {
+    size_t c;
+    size_t os=omSizeOfAddr(d);
+    if (ns>os) c=os; else c=ns;
+    memcpy(n,d,c);
+    omFree(d);
+  }
+  return n;
+}
+static inline void omFreeSize(void *d, size_t s)
+{ if (d!=NULL) { long *dd=(long*)d; dd--; free(dd);}}
+
+static inline char * omStrDup(const char *s)
+{ size_t l=strlen(s);char *ns=(char *)omAlloc(l+1);
+  return strcpy(ns,s);
+}
+static inline void * omMemDup(void * s)
+{ long *n;long *d=(long*)s; d--;
+  n=(long*)malloc(*d+sizeof(long));
+  memcpy(n,d,(*d)+sizeof(long));
+  n++;
+  return n;
+}
+
+#define omSizeWOfAddr(P)         (omSizeOfAddr(P)/sizeof(long))
+#define omTypeAllocBin(T,P,B)    P=(T)omAlloc(B)
+#define omTypeAlloc(T,P,S)       P=(T)omAlloc(S)
+#define omTypeAlloc0Bin(T,P,B)   P=(T)omAlloc0(B)
+#define omalloc(S)               omAlloc(S)
+#define omAlloc0Aligned(S)       omAlloc0(S)
+#define omAllocAligned(S)        omAlloc(S)
+#define omAllocBin(B)            omAlloc(B)
+#define omAllocBin0(B)           omAlloc0(B)
+#define omAlloc0Bin(B)           omAlloc0(B)
+#define omInitInfo()             
+#define omInitGetBackTrace()
+#define omUpdateInfo()             
+#define omPrintStats(F)
+#define omPrintInfo(F)
+#define omPrintBinStats(F)
+#define omMarkMemoryAsStatic()
+#define omfree(P)                omFree(P)
+#define omFree(P)                omFree(P)
+#define omFreeBin(P,B)           omFree(P)
+#define omfreeSize(P,S)          omFreeSize(P,S)
+#define omFreeFunc               omFree
+#define omFreeBinAddr(P)         omFree(P)
+#define omrealloc(A,NS)          omRealloc(A,NS)
+#define omreallocSize(A,OS,NS)   omRealloc(A,NS)
+#define omRealloc0Size(A,OS,NS)  omRealloc0(A,NS)
+#define omrealloc0Size(A,OS,NS)  omRealloc(A,NS)
+#define omMarkAsStaticAddr(A)
+#define omMemCpyW(A,B,S)         memcpy(A,B,(S)<<2)
+#define omMemcpyW(A,B,S)         memcpy(A,B,(S)<<2)
+#define omGetSpecBin(A)          (A)
+#define omUnGetSpecBin(A)        ((void)0)
+#define memcpyW(A,B,C)         memcpy(A,B,(C)*sizeof(long))
+#define omGetStickyBinOfBin(B) omGetSpecBin(B)
+
+
+/* debug dummies: */
+#define omTypeReallocAlignedSize     omTypeReallocSize
+#define omTypeRealloc0AlignedSize    omTypeRealloc0Size
+#define omReallocAlignedSize         omReallocSize
+#define omRealloc0AlignedSize        omRealloc0Size
+#define omMemDupAligned     omMemDup
+#define omCheckIf(cond, test)                    ((void) 0)
+#define omCheckBinAddr(addr)                     ((void) 0)
+#define omCheckAddrBin(addr,bin)                 ((void) 0)
+#define omCheckBinAddrSize(addr,size)            ((void) 0)
+#define omCheckAddrSize(addr,size)               ((void) 0)
+#define omCheckAddr(addr)                        ((void) 0)
+#define omcheckAddrSize(addr,size)               ((void) 0)
+#define omcheckAddr(addr)                        ((void) 0)
+#define omCheckBin(bin)                          ((void) 0)
+#define omCheckMemory()                          ((void) 0)
+#define omPrintCurrentBackTraceMax(A,B)          ((void) 0)
+#define omdebugAddrSize(A,B)                     ((void) 0)
+#define omPrintAddrInfo(A,B,C)                   ((void) 0)
+#define omIsBinPageAddr(A)                       ((void) 0)
+#define omTestBinAddrSize(A,B,C)                 (omError_NoError)
+#define omInitRet_2_Info(argv0)                  ((void) 0)
+#define omMergeStickyBinIntoBin(A,B)             ((void) 0)
+
+enum omError_e
+{
+  omError_NoError = 0,
+  omError_Unknown
+};
+
+#define omTestList(ptr, level)                   (omError_NoError)
+
+
+char * omFindExec (const char *name, char* executable);
+
+#ifdef __cplusplus
+}
+#endif
+
+#undef OMALLOC_USES_MALLOC
+#define X_OMALLOC
+#define omMallocFunc omAlloc
+#define omReallocSizeFunc omReallocSize
+#define omFreeSizeFunc omFreeSize
+/* #define OM_NDEBUG */
+#undef OM_SING_KEEP
+#endif
